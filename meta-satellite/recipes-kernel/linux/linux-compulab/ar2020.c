// SPDX-License-Identifier: GPL-2.0
/*
 * AR2020 driver for IMX93
 * Version: 3.0.0
 * Author: Cao Hieu
 */
#include <asm/unaligned.h>

#include <linux/types.h>
#include <linux/clk.h>
#include <linux/device.h>
#include <linux/delay.h>
#include <linux/gpio/consumer.h>
#include <linux/i2c.h>
#include <linux/module.h>
#include <linux/pm_runtime.h>
#include <linux/regulator/consumer.h>
#include <linux/sysfs.h>
#include <linux/slab.h>
#include <linux/version.h>

#include <media/v4l2-fwnode.h>
#include <media/v4l2-subdev.h>
#include <media/v4l2-ctrls.h>
#include <media/media-entity.h>

#include <linux/of.h>
#include <linux/of_device.h>
#include <linux/of_gpio.h>

#define V4L2_CID_USER_AR2020_BASE        (V4L2_CID_USER_BASE + 0x2000)
#define V4L2_CID_AR2020_SET_REGISTER     (V4L2_CID_USER_AR2020_BASE + 0)
#define V4L2_CID_AR2020_CLEAR_CUSTOM_REGS (V4L2_CID_USER_AR2020_BASE + 1)

// Sensor info
#define BAYER_CFA                   "grbg"
#define DRIVER_VERSION              KERNEL_VERSION(0, 0x01, 0x02)               // Version control
#define AR2020_NAME                 "ar2020"
#define AR2020_LANES                2
#define AR2020_BPP                  10                                          // RAW10
#define MIPI_FREQ_600M              600000000ULL                                // MIPI clock 600 MHz
#define PIXEL_RATE                  (MIPI_FREQ_600M / AR2020_BPP * AR2020_LANES)
#define AR2020_XVCLK_FREQ		    27000000      

// Hardware configuration with ABOVE-INFO
/* Input clock rate - 27Mhz? */
#define AR2020_INCLK_RATE	        27000000 
/* CSI2 HW configuration */
#define AR2020_LINK_FREQ	        MIPI_FREQ_600M  

#define CHIP_ID                     0x0653
#define AR2020_REG_CHIP_ID          0x0016
#define AR2020_REG_CTRL_MODE        0x0100
#define AR2020_MODE_SW_STANDBY      0x00
#define AR2020_MODE_STREAMING       0x01
#define AR2020_REG_EXP              0x0202
#define AR2020_REG_GAIN             0x3062
#define AR2020_REG_VTS              0x0340
#define AR2020_REG_SOFTWARE_RESET   0x0103

#define AR2020_EXPOSURE_MIN         2
#define AR2020_EXPOSURE_STEP        1
#define AR2020_VTS_MAX              0xFFFF
#define AR2020_GAIN_MIN             0
#define AR2020_GAIN_MAX             127
#define AR2020_GAIN_STEP            1
#define AR2020_GAIN_DEFAULT         0x20

#define REG_NULL                    0xFFFF
#define REG_DELAY                   0xFFFE
#define AR2020_REG_VALUE_08BIT      1
#define AR2020_REG_VALUE_16BIT      2
#define AR2020_MAX_CUSTOM_REGS      32

static const char * const ar2020_supply_names[] = {
    "avdd",  // 2.8V
    "dovdd", // 1.8V
    "dvdd",  // 1.2V
};

#define AR2020_NUM_SUPPLIES         ARRAY_SIZE(ar2020_supply_names)

/* Structure for custom register settings via V4L2 control */
struct ar2020_custom_reg {
    u16 addr;    /* Register address */
    u16 val;     /* Register value */
    u8 bits;     /* Bit width (8 or 16) */
    bool enabled; /* Whether this register is set */
};

struct regval {
    u16 addr;
    u16 val;
    u8 bits;
};

/**
 * struct ar2020_mode - ar2020 sensor mode structure
 * @width: Frame width
 * @height: Frame height
 * @code: Format code
 * @hblank: Horizontal blanking in lines
 * @vblank: Vertical blanking in lines
 * @vblank_min: Minimum vertical blanking in lines
 * @vblank_max: Maximum vertical blanking in lines
 * @pclk: Sensor pixel clock
 * @link_freq_idx: Link frequency index
 * @reg_list: Register list for sensor mode
 */

struct ar2020_mode {
	u32 width;
	u32 height;
    struct v4l2_fract max_fps;
	u32 hblank;
	u32 vblank;
	u32 vblank_min;
	u32 vblank_max;
	u64 pclk;
	u32 link_freq_idx;
    u32 hts_def;
    u32 vts_def;
    u32 exp_def;
    u32 code;
	const struct regval *reg_list;
};
//     struct v4l2_subdev sd;
//     struct v4l2_subdev subdev;
struct ar2020 {
    struct device *dev;
    struct i2c_client *client;
    struct v4l2_subdev sd;
    struct media_pad pad;
    struct clk *xvclk;
    struct gpio_desc *reset_gpio;
    struct gpio_desc *pwdn_gpio;
    struct regulator_bulk_data supplies[AR2020_NUM_SUPPLIES];
    struct v4l2_ctrl_handler ctrl_handler;
    struct v4l2_ctrl *link_freq_ctrl;
    struct v4l2_ctrl *exposure;
    struct v4l2_ctrl *anal_gain;
    struct v4l2_ctrl *vblank_ctrl;
    struct v4l2_ctrl *hblank_ctrl;
    struct v4l2_ctrl *pixel_rate;
    struct v4l2_ctrl *test_pattern; 
    struct v4l2_ctrl *custom_regs; /* New control for custom registers */
    struct v4l2_ctrl *clear_custom_regs;
    struct ar2020_custom_reg custom_regs_array[AR2020_MAX_CUSTOM_REGS]; /* Storage for custom registers */ 
    struct mutex mutex;
    bool streaming;
    const struct ar2020_mode *cur_mode;
};

/**
 * to_ar2020() - ar2020 V4L2 sub-device to ar2020 device.
 * @subdev: pointer to ar2020 V4L2 sub-device
 *
 * Return: pointer to ar2020 device
 */
static inline struct ar2020 *to_ar2020(struct v4l2_subdev *subdev)
{
	return container_of(subdev, struct ar2020, sd);
}

static const s64 link_freq[] = {
	AR2020_LINK_FREQ,
};

/* Sensor mode registers */
static const struct regval MIPI_2lane__5120x3840_Linear_7p5fps[] = {
    { 0x0100, 0x0000, AR2020_REG_VALUE_16BIT },
    // { REG_DELAY, 1000,   AR2020_REG_VALUE_16BIT },

    /* --- PLL VT (Video Timing) EXTCLK = 27 MHz 171.75MHz--- */
    { 0x0304, 0x0006, AR2020_REG_VALUE_16BIT },     /* [0x0304] VT_PRE_PLL_CLK_DIV = 0x09 */
    { 0x0306, 0x00E5, AR2020_REG_VALUE_16BIT },     /* [0x0306] VT_PLL_MULTIPLIER = 0x0190  (400 decimal) */
    { 0x0300, 0x0006, AR2020_REG_VALUE_16BIT },     /* [0x0300] VT_PIX_CLK_DIV = 0x07 */
    { 0x0302, 0x0001, AR2020_REG_VALUE_16BIT },     /* [0x0302] VT_SYS_CLK_DIV = 0x01 */

    /* --- PLL OP (Output Path) OP_PIX = 60 MHz --- */
    { 0x0308, 0x0005, AR2020_REG_VALUE_16BIT },     /* OP_PIX_CLK_DIV = 0x0005 */
    { 0x030A, 0x0002, AR2020_REG_VALUE_16BIT },     /* OP_SYS_CLK_DIV = 0x0002 */
    { 0x030C, 0x0007, AR2020_REG_VALUE_16BIT },     /* OP_PRE_PLL_CLK_DIV = 0x0007 */
    { 0x030E, 0x009B, AR2020_REG_VALUE_16BIT },     /* OP_PLL_MULTIPLIER = 0x009B */
    
    { 0x0340, 0x1BC4, AR2020_REG_VALUE_16BIT },     /* FRAME_LENGTH_LINES = 0x1BC4 */
    { 0x0342, 0xFFF0, AR2020_REG_VALUE_16BIT },     /* LINE_LENGTH_PCK = 0xFFF0 */
    
    { 0x3EC8, 0x0200, AR2020_REG_VALUE_16BIT },     /* X_OUTPUT_OFFSET = 0x0000 */
    { 0x3ECA, 0x0000, AR2020_REG_VALUE_16BIT },     /* Y_OUTPUT_OFFSET = 0x0000 */
    
    { 0x3F18, 0x7B70, AR2020_REG_VALUE_16BIT },     /* MIPI_JPEG_PN9_DATA_TYPE = 0x7B70 */
    { 0x3F20, 0x8000, AR2020_REG_VALUE_16BIT },     /* MIPI_PHY_TRIM_MSB = 0x8000 */

    { 0x0344, 0x0008, AR2020_REG_VALUE_16BIT },     /* [0x0344] X_ADDR_START = 0x0008 */
    { 0x0348, 0x1407, AR2020_REG_VALUE_16BIT },     /* [0x0348] X_ADDR_END   =  */ 
    { 0x0346, 0x0008, AR2020_REG_VALUE_16BIT },     /* [0x0346] Y_ADDR_START = 0x0008 */
    { 0x034A, 0x0F07, AR2020_REG_VALUE_16BIT },     /* [0x034A] Y_ADDR_END   =  */
    { 0x034C, 0x1400, AR2020_REG_VALUE_16BIT },     /* [0x034C] X_OUTPUT_SIZE = 0x1000 (4096) */
    { 0x034E, 0x0F00, AR2020_REG_VALUE_16BIT },     /* [0x034E] Y_OUTPUT_SIZE = 0x0C00 (3072) */

    { 0x0380, 0x0001, AR2020_REG_VALUE_16BIT },     /* [0x0380] X_EVEN_INC = 0x01 */
    { 0x0382, 0x0001, AR2020_REG_VALUE_16BIT },     /* [0x0382] X_ODD_INC  = 0x01 */
    { 0x0384, 0x0001, AR2020_REG_VALUE_16BIT },     /* [0x0384] Y_EVEN_INC = 0x01 */
    { 0x0386, 0x0001, AR2020_REG_VALUE_16BIT },     /* [0x0386] Y_ODD_INC  = 0x01 */

    { 0x0900, 0x0000, AR2020_REG_VALUE_16BIT },     /* [0x0900] BINNING_MODE = 0x00 */               
    { 0x0901, 0x0011, AR2020_REG_VALUE_16BIT },     /* [0x0901] BINNING_TYPE = 0x11 */               

    // /* --- Fundamental exposer  (Integration) --- */
    // { 0x0202, 0x0240, AR2020_REG_VALUE_16BIT },  /* [0x0202] COARSE_INTEGRATION_TIME = 0x0003 */ /*<- Expose time set */
    // { 0x3062, 0x0000, AR2020_REG_VALUE_16BIT },  /*<- Expose time set */
    { 0x0112, 0x0A0A, AR2020_REG_VALUE_16BIT },     /* [0x0112] CSI_DATA_FORMAT = 0x0A0A */
    { 0x0114, 0x0001, AR2020_REG_VALUE_08BIT },     /* [0x0114] CSI_LANE_MODE   = 0x0001 */

    /* --- MIPI PHY (boost, trim) --- */
    // { 0x3F06, 0x00C0, AR2020_REG_VALUE_16BIT },    /* [0x3F06] MIPI_TIMING_2 = 0x00C0 */
    // { 0x3F0A, 0xA000, AR2020_REG_VALUE_16BIT },    /* [0x3F0A] MIPI_TIMING_4 = 0xA000 */
    // { 0x3F0C, 0x0007, AR2020_REG_VALUE_16BIT },    /* [0x3F0C] MIPI_TIMING_5 = 0x0007 */
    // { 0x3F20, 0x8008, AR2020_REG_VALUE_16BIT },    /* [0x3F20] MIPI_PHY_TRIM_MSB = 0x8008 */
    // { 0x3F1E, 0x0000, AR2020_REG_VALUE_16BIT },    /* [0x3F1E] MIPI_PHY_TRIM_LSB = 0x0000 */

    // /* --- GAIN TABLE LINEAR REV1--- */
    { 0x5500, 0x0000, AR2020_REG_VALUE_16BIT },     /* reserved_mfr_5500 = 0x0   */
    { 0x5502, 0x0002, AR2020_REG_VALUE_16BIT },     /* reserved_mfr_5502 = 0x2   */
    { 0x5504, 0x0006, AR2020_REG_VALUE_16BIT },     /* reserved_mfr_5504 = 0x6   */
    { 0x5506, 0x0009, AR2020_REG_VALUE_16BIT },     /* reserved_mfr_5506 = 0x9   */
    { 0x5508, 0x000F, AR2020_REG_VALUE_16BIT },     /* reserved_mfr_5508 = 0xF   */
    { 0x550A, 0x0010, AR2020_REG_VALUE_16BIT },     /* reserved_mfr_550A = 0x10  */
    { 0x550C, 0x0011, AR2020_REG_VALUE_16BIT },     /* reserved_mfr_550C = 0x11  */
    { 0x550E, 0x0012, AR2020_REG_VALUE_16BIT },     /* reserved_mfr_550E = 0x12  */
    { 0x5510, 0x0019, AR2020_REG_VALUE_16BIT },     /* reserved_mfr_5510 = 0x19  */
    { 0x5512, 0x0020, AR2020_REG_VALUE_16BIT },     /* reserved_mfr_5512 = 0x20  */
    { 0x5514, 0x0021, AR2020_REG_VALUE_16BIT },     /* reserved_mfr_5514 = 0x21  */
    { 0x5516, 0x0023, AR2020_REG_VALUE_16BIT },     /* reserved_mfr_5516 = 0x23  */
    { 0x5518, 0x0026, AR2020_REG_VALUE_16BIT },     /* reserved_mfr_5518 = 0x26  */
    { 0x551A, 0x002B, AR2020_REG_VALUE_16BIT },     /* reserved_mfr_551A = 0x2B  */
    { 0x551C, 0x002F, AR2020_REG_VALUE_16BIT },     /* reserved_mfr_551C = 0x2F  */
    { 0x551E, 0x0030, AR2020_REG_VALUE_16BIT },     /* reserved_mfr_551E = 0x30  */

    { 0x5400, 0x0100, AR2020_REG_VALUE_16BIT },     /* reserved_mfr_5400 = 0x0100  */
    { 0x5402, 0x2106, AR2020_REG_VALUE_16BIT },     /* reserved_mfr_5402 = 0x2106  */
    { 0x5404, 0x1101, AR2020_REG_VALUE_16BIT },     /* reserved_mfr_5404 = 0x1101  */
    { 0x5406, 0x3106, AR2020_REG_VALUE_16BIT },     /* reserved_mfr_5406 = 0x3106  */
    { 0x5408, 0x7100, AR2020_REG_VALUE_16BIT },     /* reserved_mfr_5408 = 0x7100  */
    { 0x540A, 0x8107, AR2020_REG_VALUE_16BIT },     /* reserved_mfr_540A = 0x8107  */
    { 0x540C, 0xB101, AR2020_REG_VALUE_16BIT },     /* reserved_mfr_540C = 0xB101  */
    { 0x540E, 0xD101, AR2020_REG_VALUE_16BIT },     /* reserved_mfr_540E = 0xD101  */
    { 0x5410, 0xF12E, AR2020_REG_VALUE_16BIT },     /* reserved_mfr_5410 = 0xF12E  */
    { 0x5412, 0xF112, AR2020_REG_VALUE_16BIT },     /* reserved_mfr_5412 = 0xF112  */
    { 0x5414, 0xF184, AR2020_REG_VALUE_16BIT },     /* reserved_mfr_5414 = 0xF184  */
    { 0x5416, 0xF224, AR2020_REG_VALUE_16BIT },     /* reserved_mfr_5416 = 0xF224  */
    { 0x5418, 0xF306, AR2020_REG_VALUE_16BIT },     /* reserved_mfr_5418 = 0xF306  */
    { 0x541A, 0xF446, AR2020_REG_VALUE_16BIT },     /* reserved_mfr_541A = 0xF446  */
    { 0x541C, 0xF609, AR2020_REG_VALUE_16BIT },     /* reserved_mfr_541C = 0xF609  */
    { 0x541E, 0xF887, AR2020_REG_VALUE_16BIT },     /* reserved_mfr_541E = 0xF887  */
    { 0x5420, 0xFC0B, AR2020_REG_VALUE_16BIT },     /* reserved_mfr_5420 = 0xFC0B  */
    { 0x5422, 0xFC0B, AR2020_REG_VALUE_16BIT },     /* reserved_mfr_5422 = 0xFC0B  */
    { 0x5424, 0xFFFA, AR2020_REG_VALUE_16BIT },     /* reserved_mfr_5424 = 0xFFFA  */
    { 0x5426, 0x5557, AR2020_REG_VALUE_16BIT },     /* reserved_mfr_5426 = 0x5557  */
    { 0x5428, 0x0005, AR2020_REG_VALUE_16BIT },     /* reserved_mfr_5428 = 0x0005  */
    { 0x542A, 0xA550, AR2020_REG_VALUE_16BIT },     /* reserved_mfr_542A = 0xA550  */
    { 0x542C, 0xAAAA, AR2020_REG_VALUE_16BIT },     /* reserved_mfr_542C = 0xAAAA  */
    { 0x542E, 0x000A, AR2020_REG_VALUE_16BIT },     /* reserved_mfr_542E = 0x000A  */

    { 0x5460, 0x2269, AR2020_REG_VALUE_16BIT },     /* reserved_mfr_5460 = 0x2269  */
    { 0x5462, 0x0B87, AR2020_REG_VALUE_16BIT },     /* reserved_mfr_5462 = 0x0B87  */
    { 0x5464, 0x0B87, AR2020_REG_VALUE_16BIT },     /* reserved_mfr_5464 = 0x0B87  */
    { 0x5466, 0x0983, AR2020_REG_VALUE_16BIT },     /* reserved_mfr_5466 = 0x0983  */

    { 0x5498, 0x225E, AR2020_REG_VALUE_16BIT },     /* reserved_mfr_5498 = 0x225E  */
    { 0x549A, 0xBCAA, AR2020_REG_VALUE_16BIT },     /* reserved_mfr_549A = 0xBCAA  */
    { 0x549C, 0xBCAA, AR2020_REG_VALUE_16BIT },     /* reserved_mfr_549C = 0xBCAA  */
    { 0x549E, 0xBDAA, AR2020_REG_VALUE_16BIT },     /* reserved_mfr_549E = 0xBDAA  */

    /* [0x3060] GAIN_TABLE_CTRL = 0xFF01 */
    { 0x3060, 0xFF01, AR2020_REG_VALUE_16BIT },     /* gain_table_ctrl = 0xFF01  */
    /* --- END GAIN TABLE--- */
    { REG_DELAY, 1000, AR2020_REG_VALUE_16BIT },
    
    /* --- TIMING ANALOG RECOMMEND POR --- */
    { 0x4000, 0x0114, AR2020_REG_VALUE_16BIT },
    { 0x4002, 0x1A25, AR2020_REG_VALUE_16BIT },
    { 0x4004, 0x3DFF, AR2020_REG_VALUE_16BIT },
    { 0x4006, 0xFFFF, AR2020_REG_VALUE_16BIT },
    { 0x4008, 0x0A35, AR2020_REG_VALUE_16BIT },
    { 0x400A, 0x10EF, AR2020_REG_VALUE_16BIT },
    { 0x400C, 0x3003, AR2020_REG_VALUE_16BIT },
    { 0x400E, 0x30D8, AR2020_REG_VALUE_16BIT },
    { 0x4010, 0xF003, AR2020_REG_VALUE_16BIT },
    { 0x4012, 0xB5F0, AR2020_REG_VALUE_16BIT },
    { 0x4014, 0x0085, AR2020_REG_VALUE_16BIT },
    { 0x4016, 0xF004, AR2020_REG_VALUE_16BIT },
    { 0x4018, 0x9A89, AR2020_REG_VALUE_16BIT },
    { 0x401A, 0xF000, AR2020_REG_VALUE_16BIT },
    { 0x401C, 0x9997, AR2020_REG_VALUE_16BIT },
    { 0x401E, 0xF000, AR2020_REG_VALUE_16BIT },
    { 0x4020, 0x30C0, AR2020_REG_VALUE_16BIT },
    { 0x4022, 0xF000, AR2020_REG_VALUE_16BIT },
    { 0x4024, 0x82F0, AR2020_REG_VALUE_16BIT },
    { 0x4026, 0x0030, AR2020_REG_VALUE_16BIT },
    { 0x4028, 0x18F0, AR2020_REG_VALUE_16BIT },
    { 0x402A, 0x0320, AR2020_REG_VALUE_16BIT },
    { 0x402C, 0x58F0, AR2020_REG_VALUE_16BIT },
    { 0x402E, 0x089C, AR2020_REG_VALUE_16BIT },
    { 0x4030, 0xF010, AR2020_REG_VALUE_16BIT },
    { 0x4032, 0x99B6, AR2020_REG_VALUE_16BIT },
    { 0x4034, 0xF003, AR2020_REG_VALUE_16BIT },
    { 0x4036, 0xB498, AR2020_REG_VALUE_16BIT },
    { 0x4038, 0xA096, AR2020_REG_VALUE_16BIT },
    { 0x403A, 0xF000, AR2020_REG_VALUE_16BIT },
    { 0x403C, 0xA2F0, AR2020_REG_VALUE_16BIT },
    { 0x403E, 0x00A2, AR2020_REG_VALUE_16BIT },
    { 0x4040, 0xF008, AR2020_REG_VALUE_16BIT },
    { 0x4042, 0x9DF0, AR2020_REG_VALUE_16BIT },
    { 0x4044, 0x209D, AR2020_REG_VALUE_16BIT },
    { 0x4046, 0x8C08, AR2020_REG_VALUE_16BIT },
    { 0x4048, 0x08F0, AR2020_REG_VALUE_16BIT },
    { 0x404A, 0x0036, AR2020_REG_VALUE_16BIT },
    { 0x404C, 0x008F, AR2020_REG_VALUE_16BIT },
    { 0x404E, 0xF000, AR2020_REG_VALUE_16BIT },
    { 0x4050, 0x88F0, AR2020_REG_VALUE_16BIT },
    { 0x4052, 0x0488, AR2020_REG_VALUE_16BIT },
    { 0x4054, 0xF000, AR2020_REG_VALUE_16BIT },
    { 0x4056, 0x3600, AR2020_REG_VALUE_16BIT },
    { 0x4058, 0xF000, AR2020_REG_VALUE_16BIT },
    { 0x405A, 0x83F0, AR2020_REG_VALUE_16BIT },
    { 0x405C, 0x0290, AR2020_REG_VALUE_16BIT },
    { 0x405E, 0xF000, AR2020_REG_VALUE_16BIT },
    { 0x4060, 0x8BF0, AR2020_REG_VALUE_16BIT },
    { 0x4062, 0x2EA3, AR2020_REG_VALUE_16BIT },
    { 0x4064, 0xF000, AR2020_REG_VALUE_16BIT },
    { 0x4066, 0xA3F0, AR2020_REG_VALUE_16BIT },
    { 0x4068, 0x089D, AR2020_REG_VALUE_16BIT },
    { 0x406A, 0xF075, AR2020_REG_VALUE_16BIT },
    { 0x406C, 0x3003, AR2020_REG_VALUE_16BIT },
    { 0x406E, 0x4070, AR2020_REG_VALUE_16BIT },
    { 0x4070, 0x216D, AR2020_REG_VALUE_16BIT },
    { 0x4072, 0x1CF6, AR2020_REG_VALUE_16BIT },
    { 0x4074, 0x8B00, AR2020_REG_VALUE_16BIT },
    { 0x4076, 0x5186, AR2020_REG_VALUE_16BIT },
    { 0x4078, 0x1300, AR2020_REG_VALUE_16BIT },
    { 0x407A, 0x0205, AR2020_REG_VALUE_16BIT },
    { 0x407C, 0x36D8, AR2020_REG_VALUE_16BIT },
    { 0x407E, 0xF002, AR2020_REG_VALUE_16BIT },
    { 0x4080, 0x8387, AR2020_REG_VALUE_16BIT },
    { 0x4082, 0xF006, AR2020_REG_VALUE_16BIT },
    { 0x4084, 0x8702, AR2020_REG_VALUE_16BIT },
    { 0x4086, 0x0D02, AR2020_REG_VALUE_16BIT },
    { 0x4088, 0x05F0, AR2020_REG_VALUE_16BIT },
    { 0x408A, 0x0383, AR2020_REG_VALUE_16BIT },
    { 0x408C, 0xF001, AR2020_REG_VALUE_16BIT },
    { 0x408E, 0x87F0, AR2020_REG_VALUE_16BIT },
    { 0x4090, 0x0213, AR2020_REG_VALUE_16BIT },
    { 0x4092, 0x0036, AR2020_REG_VALUE_16BIT },
    { 0x4094, 0xD887, AR2020_REG_VALUE_16BIT },
    { 0x4096, 0x020D, AR2020_REG_VALUE_16BIT },
    { 0x4098, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x409A, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x409C, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x409E, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x40A0, 0xF000, AR2020_REG_VALUE_16BIT },
    { 0x40A2, 0x0401, AR2020_REG_VALUE_16BIT },
    { 0x40A4, 0xF008, AR2020_REG_VALUE_16BIT },
    { 0x40A6, 0x82F0, AR2020_REG_VALUE_16BIT },
    { 0x40A8, 0x0883, AR2020_REG_VALUE_16BIT },
    { 0x40AA, 0xF009, AR2020_REG_VALUE_16BIT },
    { 0x40AC, 0x85F0, AR2020_REG_VALUE_16BIT },
    { 0x40AE, 0x2985, AR2020_REG_VALUE_16BIT },
    { 0x40B0, 0x87F0, AR2020_REG_VALUE_16BIT },
    { 0x40B2, 0x2A87, AR2020_REG_VALUE_16BIT },
    { 0x40B4, 0xF63E, AR2020_REG_VALUE_16BIT },
    { 0x40B6, 0x88F0, AR2020_REG_VALUE_16BIT },
    { 0x40B8, 0x0801, AR2020_REG_VALUE_16BIT },
    { 0x40BA, 0x40F0, AR2020_REG_VALUE_16BIT },
    { 0x40BC, 0x0800, AR2020_REG_VALUE_16BIT },
    { 0x40BE, 0x48F0, AR2020_REG_VALUE_16BIT },
    { 0x40C0, 0x0882, AR2020_REG_VALUE_16BIT },
    { 0x40C2, 0xF008, AR2020_REG_VALUE_16BIT },
    { 0x40C4, 0x0401, AR2020_REG_VALUE_16BIT },
    { 0x40C6, 0xF008, AR2020_REG_VALUE_16BIT },
    { 0x40C8, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x40CA, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x40CC, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x40CE, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x40D0, 0xF000, AR2020_REG_VALUE_16BIT },
    { 0x40D2, 0x0401, AR2020_REG_VALUE_16BIT },
    { 0x40D4, 0xF015, AR2020_REG_VALUE_16BIT },
    { 0x40D6, 0x002C, AR2020_REG_VALUE_16BIT },
    { 0x40D8, 0xF00E, AR2020_REG_VALUE_16BIT },
    { 0x40DA, 0x85F0, AR2020_REG_VALUE_16BIT },
    { 0x40DC, 0x0687, AR2020_REG_VALUE_16BIT },
    { 0x40DE, 0xF002, AR2020_REG_VALUE_16BIT },
    { 0x40E0, 0x87F0, AR2020_REG_VALUE_16BIT },
    { 0x40E2, 0x61E8, AR2020_REG_VALUE_16BIT },
    { 0x40E4, 0x3900, AR2020_REG_VALUE_16BIT },
    { 0x40E6, 0xF005, AR2020_REG_VALUE_16BIT },
    { 0x40E8, 0x3480, AR2020_REG_VALUE_16BIT },
    { 0x40EA, 0xF000, AR2020_REG_VALUE_16BIT },
    { 0x40EC, 0x3240, AR2020_REG_VALUE_16BIT },
    { 0x40EE, 0xF000, AR2020_REG_VALUE_16BIT },
    { 0x40F0, 0x3900, AR2020_REG_VALUE_16BIT },
    { 0x40F2, 0xF00E, AR2020_REG_VALUE_16BIT },
    { 0x40F4, 0x3900, AR2020_REG_VALUE_16BIT },
    { 0x40F6, 0xF000, AR2020_REG_VALUE_16BIT },
    { 0x40F8, 0x3240, AR2020_REG_VALUE_16BIT },
    { 0x40FA, 0xF000, AR2020_REG_VALUE_16BIT },
    { 0x40FC, 0x3480, AR2020_REG_VALUE_16BIT },
    { 0x40FE, 0xF005, AR2020_REG_VALUE_16BIT },
    { 0x4100, 0xC0E6, AR2020_REG_VALUE_16BIT },
    { 0x4102, 0xF004, AR2020_REG_VALUE_16BIT },
    { 0x4104, 0x3900, AR2020_REG_VALUE_16BIT },
    { 0x4106, 0xF003, AR2020_REG_VALUE_16BIT },
    { 0x4108, 0xB0F0, AR2020_REG_VALUE_16BIT },
    { 0x410A, 0x0083, AR2020_REG_VALUE_16BIT },
    { 0x410C, 0xF000, AR2020_REG_VALUE_16BIT },
    { 0x410E, 0x86F0, AR2020_REG_VALUE_16BIT },
    { 0x4110, 0x0086, AR2020_REG_VALUE_16BIT },
    { 0x4112, 0xF089, AR2020_REG_VALUE_16BIT },
    { 0x4114, 0xB0F0, AR2020_REG_VALUE_16BIT },
    { 0x4116, 0x00E9, AR2020_REG_VALUE_16BIT },
    { 0x4118, 0xF000, AR2020_REG_VALUE_16BIT },
    { 0x411A, 0x8AF0, AR2020_REG_VALUE_16BIT },
    { 0x411C, 0x0000, AR2020_REG_VALUE_16BIT },
    { 0x411E, 0x05F0, AR2020_REG_VALUE_16BIT },
    { 0x4120, 0x00E0, AR2020_REG_VALUE_16BIT },
    { 0x4122, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x4124, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x4126, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x4128, 0x0A35, AR2020_REG_VALUE_16BIT },
    { 0x412A, 0x10EF, AR2020_REG_VALUE_16BIT },
    { 0x412C, 0x3003, AR2020_REG_VALUE_16BIT },
    { 0x412E, 0x30D8, AR2020_REG_VALUE_16BIT },
    { 0x4130, 0xF005, AR2020_REG_VALUE_16BIT },
    { 0x4132, 0x85F0, AR2020_REG_VALUE_16BIT },
    { 0x4134, 0x049A, AR2020_REG_VALUE_16BIT },
    { 0x4136, 0x89F0, AR2020_REG_VALUE_16BIT },
    { 0x4138, 0x0099, AR2020_REG_VALUE_16BIT },
    { 0x413A, 0x97F0, AR2020_REG_VALUE_16BIT },
    { 0x413C, 0x0030, AR2020_REG_VALUE_16BIT },
    { 0x413E, 0xC0F0, AR2020_REG_VALUE_16BIT },
    { 0x4140, 0x0082, AR2020_REG_VALUE_16BIT },
    { 0x4142, 0xF000, AR2020_REG_VALUE_16BIT },
    { 0x4144, 0x3018, AR2020_REG_VALUE_16BIT },
    { 0x4146, 0xF002, AR2020_REG_VALUE_16BIT },
    { 0x4148, 0xB520, AR2020_REG_VALUE_16BIT },
    { 0x414A, 0x58F0, AR2020_REG_VALUE_16BIT },
    { 0x414C, 0x089C, AR2020_REG_VALUE_16BIT },
    { 0x414E, 0xF010, AR2020_REG_VALUE_16BIT },
    { 0x4150, 0x99B6, AR2020_REG_VALUE_16BIT },
    { 0x4152, 0xF003, AR2020_REG_VALUE_16BIT },
    { 0x4154, 0xB498, AR2020_REG_VALUE_16BIT },
    { 0x4156, 0xA096, AR2020_REG_VALUE_16BIT },
    { 0x4158, 0xF000, AR2020_REG_VALUE_16BIT },
    { 0x415A, 0xA2F0, AR2020_REG_VALUE_16BIT },
    { 0x415C, 0x00A2, AR2020_REG_VALUE_16BIT },
    { 0x415E, 0xF008, AR2020_REG_VALUE_16BIT },
    { 0x4160, 0x9DF0, AR2020_REG_VALUE_16BIT },
    { 0x4162, 0x209D, AR2020_REG_VALUE_16BIT },
    { 0x4164, 0x8C08, AR2020_REG_VALUE_16BIT },
    { 0x4166, 0x08F0, AR2020_REG_VALUE_16BIT },
    { 0x4168, 0x0036, AR2020_REG_VALUE_16BIT },
    { 0x416A, 0x008F, AR2020_REG_VALUE_16BIT },
    { 0x416C, 0x88F0, AR2020_REG_VALUE_16BIT },
    { 0x416E, 0x0188, AR2020_REG_VALUE_16BIT },
    { 0x4170, 0x3600, AR2020_REG_VALUE_16BIT },
    { 0x4172, 0xF000, AR2020_REG_VALUE_16BIT },
    { 0x4174, 0x83F0, AR2020_REG_VALUE_16BIT },
    { 0x4176, 0x0290, AR2020_REG_VALUE_16BIT },
    { 0x4178, 0xF001, AR2020_REG_VALUE_16BIT },
    { 0x417A, 0x8BF0, AR2020_REG_VALUE_16BIT },
    { 0x417C, 0x2DA3, AR2020_REG_VALUE_16BIT },
    { 0x417E, 0xF000, AR2020_REG_VALUE_16BIT },
    { 0x4180, 0xA3F0, AR2020_REG_VALUE_16BIT },
    { 0x4182, 0x089D, AR2020_REG_VALUE_16BIT },
    { 0x4184, 0xF06D, AR2020_REG_VALUE_16BIT },
    { 0x4186, 0x4070, AR2020_REG_VALUE_16BIT },
    { 0x4188, 0x3003, AR2020_REG_VALUE_16BIT },
    { 0x418A, 0x214D, AR2020_REG_VALUE_16BIT },
    { 0x418C, 0x1FF6, AR2020_REG_VALUE_16BIT },
    { 0x418E, 0x0851, AR2020_REG_VALUE_16BIT },
    { 0x4190, 0x0245, AR2020_REG_VALUE_16BIT },
    { 0x4192, 0x9D36, AR2020_REG_VALUE_16BIT },
    { 0x4194, 0xD8F0, AR2020_REG_VALUE_16BIT },
    { 0x4196, 0x0083, AR2020_REG_VALUE_16BIT },
    { 0x4198, 0xF000, AR2020_REG_VALUE_16BIT },
    { 0x419A, 0x87F0, AR2020_REG_VALUE_16BIT },
    { 0x419C, 0x0087, AR2020_REG_VALUE_16BIT },
    { 0x419E, 0xF000, AR2020_REG_VALUE_16BIT },
    { 0x41A0, 0x36D8, AR2020_REG_VALUE_16BIT },
    { 0x41A2, 0x020D, AR2020_REG_VALUE_16BIT },
    { 0x41A4, 0x0205, AR2020_REG_VALUE_16BIT },
    { 0x41A6, 0xF000, AR2020_REG_VALUE_16BIT },
    { 0x41A8, 0x36D8, AR2020_REG_VALUE_16BIT },
    { 0x41AA, 0xF000, AR2020_REG_VALUE_16BIT },
    { 0x41AC, 0x83F0, AR2020_REG_VALUE_16BIT },
    { 0x41AE, 0x0087, AR2020_REG_VALUE_16BIT },
    { 0x41B0, 0xF000, AR2020_REG_VALUE_16BIT },
    { 0x41B2, 0x87F0, AR2020_REG_VALUE_16BIT },
    { 0x41B4, 0x0036, AR2020_REG_VALUE_16BIT },
    { 0x41B6, 0xD802, AR2020_REG_VALUE_16BIT },
    { 0x41B8, 0x0D02, AR2020_REG_VALUE_16BIT },
    { 0x41BA, 0x05F0, AR2020_REG_VALUE_16BIT },
    { 0x41BC, 0x0036, AR2020_REG_VALUE_16BIT },
    { 0x41BE, 0xD8F0, AR2020_REG_VALUE_16BIT },
    { 0x41C0, 0x0083, AR2020_REG_VALUE_16BIT },
    { 0x41C2, 0xF000, AR2020_REG_VALUE_16BIT },
    { 0x41C4, 0x87F0, AR2020_REG_VALUE_16BIT },
    { 0x41C6, 0x0087, AR2020_REG_VALUE_16BIT },
    { 0x41C8, 0xF000, AR2020_REG_VALUE_16BIT },
    { 0x41CA, 0x36D8, AR2020_REG_VALUE_16BIT },
    { 0x41CC, 0x020D, AR2020_REG_VALUE_16BIT },
    { 0x41CE, 0x0205, AR2020_REG_VALUE_16BIT },
    { 0x41D0, 0xF000, AR2020_REG_VALUE_16BIT },
    { 0x41D2, 0x36D8, AR2020_REG_VALUE_16BIT },
    { 0x41D4, 0xF000, AR2020_REG_VALUE_16BIT },
    { 0x41D6, 0x83F0, AR2020_REG_VALUE_16BIT },
    { 0x41D8, 0x0087, AR2020_REG_VALUE_16BIT },
    { 0x41DA, 0xF000, AR2020_REG_VALUE_16BIT },
    { 0x41DC, 0x8713, AR2020_REG_VALUE_16BIT },
    { 0x41DE, 0x0036, AR2020_REG_VALUE_16BIT },
    { 0x41E0, 0xD802, AR2020_REG_VALUE_16BIT },
    { 0x41E2, 0x0DE0, AR2020_REG_VALUE_16BIT },
    { 0x41E4, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x41E6, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x41E8, 0x9F13, AR2020_REG_VALUE_16BIT },
    { 0x41EA, 0x0041, AR2020_REG_VALUE_16BIT },
    { 0x41EC, 0x80F3, AR2020_REG_VALUE_16BIT },
    { 0x41EE, 0xF213, AR2020_REG_VALUE_16BIT },
    { 0x41F0, 0x00F0, AR2020_REG_VALUE_16BIT },
    { 0x41F2, 0x13B8, AR2020_REG_VALUE_16BIT },
    { 0x41F4, 0xF04C, AR2020_REG_VALUE_16BIT },
    { 0x41F6, 0x9FF0, AR2020_REG_VALUE_16BIT },
    { 0x41F8, 0x00B7, AR2020_REG_VALUE_16BIT },
    { 0x41FA, 0xF006, AR2020_REG_VALUE_16BIT },
    { 0x41FC, 0x0035, AR2020_REG_VALUE_16BIT },
    { 0x41FE, 0x10AF, AR2020_REG_VALUE_16BIT },
    { 0x4200, 0x3003, AR2020_REG_VALUE_16BIT },
    { 0x4202, 0x30C0, AR2020_REG_VALUE_16BIT },
    { 0x4204, 0xB2F0, AR2020_REG_VALUE_16BIT },
    { 0x4206, 0x01B5, AR2020_REG_VALUE_16BIT },
    { 0x4208, 0xF001, AR2020_REG_VALUE_16BIT },
    { 0x420A, 0x85F0, AR2020_REG_VALUE_16BIT },
    { 0x420C, 0x0292, AR2020_REG_VALUE_16BIT },
    { 0x420E, 0xF000, AR2020_REG_VALUE_16BIT },
    { 0x4210, 0x9A8B, AR2020_REG_VALUE_16BIT },
    { 0x4212, 0xF000, AR2020_REG_VALUE_16BIT },
    { 0x4214, 0x9997, AR2020_REG_VALUE_16BIT },
    { 0x4216, 0xF007, AR2020_REG_VALUE_16BIT },
    { 0x4218, 0xB6F0, AR2020_REG_VALUE_16BIT },
    { 0x421A, 0x0020, AR2020_REG_VALUE_16BIT },
    { 0x421C, 0x5830, AR2020_REG_VALUE_16BIT },
    { 0x421E, 0xC040, AR2020_REG_VALUE_16BIT },
    { 0x4220, 0x1282, AR2020_REG_VALUE_16BIT },
    { 0x4222, 0xF005, AR2020_REG_VALUE_16BIT },
    { 0x4224, 0x9CF0, AR2020_REG_VALUE_16BIT },
    { 0x4226, 0x01B2, AR2020_REG_VALUE_16BIT },
    { 0x4228, 0xF008, AR2020_REG_VALUE_16BIT },
    { 0x422A, 0xB8F0, AR2020_REG_VALUE_16BIT },
    { 0x422C, 0x0799, AR2020_REG_VALUE_16BIT },
    { 0x422E, 0xF005, AR2020_REG_VALUE_16BIT },
    { 0x4230, 0x98F0, AR2020_REG_VALUE_16BIT },
    { 0x4232, 0x0296, AR2020_REG_VALUE_16BIT },
    { 0x4234, 0xA2F0, AR2020_REG_VALUE_16BIT },
    { 0x4236, 0x00A2, AR2020_REG_VALUE_16BIT },
    { 0x4238, 0xF008, AR2020_REG_VALUE_16BIT },
    { 0x423A, 0x9DF0, AR2020_REG_VALUE_16BIT },
    { 0x423C, 0x02A1, AR2020_REG_VALUE_16BIT },
    { 0x423E, 0xF01F, AR2020_REG_VALUE_16BIT },
    { 0x4240, 0x1009, AR2020_REG_VALUE_16BIT },
    { 0x4242, 0x2220, AR2020_REG_VALUE_16BIT },
    { 0x4244, 0x0808, AR2020_REG_VALUE_16BIT },
    { 0x4246, 0xF000, AR2020_REG_VALUE_16BIT },
    { 0x4248, 0x3600, AR2020_REG_VALUE_16BIT },
    { 0x424A, 0xF000, AR2020_REG_VALUE_16BIT },
    { 0x424C, 0x88F0, AR2020_REG_VALUE_16BIT },
    { 0x424E, 0x0788, AR2020_REG_VALUE_16BIT },
    { 0x4250, 0x3600, AR2020_REG_VALUE_16BIT },
    { 0x4252, 0xF000, AR2020_REG_VALUE_16BIT },
    { 0x4254, 0x83F0, AR2020_REG_VALUE_16BIT },
    { 0x4256, 0x0290, AR2020_REG_VALUE_16BIT },
    { 0x4258, 0xF016, AR2020_REG_VALUE_16BIT },
    { 0x425A, 0x8BF0, AR2020_REG_VALUE_16BIT },
    { 0x425C, 0x11A3, AR2020_REG_VALUE_16BIT },
    { 0x425E, 0xF000, AR2020_REG_VALUE_16BIT },
    { 0x4260, 0xA3F0, AR2020_REG_VALUE_16BIT },
    { 0x4262, 0x089D, AR2020_REG_VALUE_16BIT },
    { 0x4264, 0xF002, AR2020_REG_VALUE_16BIT },
    { 0x4266, 0xA1F0, AR2020_REG_VALUE_16BIT },
    { 0x4268, 0x20A1, AR2020_REG_VALUE_16BIT },
    { 0x426A, 0xF006, AR2020_REG_VALUE_16BIT },
    { 0x426C, 0x4300, AR2020_REG_VALUE_16BIT },
    { 0x426E, 0xF049, AR2020_REG_VALUE_16BIT },
    { 0x4270, 0x4014, AR2020_REG_VALUE_16BIT },
    { 0x4272, 0x8B8E, AR2020_REG_VALUE_16BIT },
    { 0x4274, 0x9DF0, AR2020_REG_VALUE_16BIT },
    { 0x4276, 0x0802, AR2020_REG_VALUE_16BIT },
    { 0x4278, 0x02F0, AR2020_REG_VALUE_16BIT },
    { 0x427A, 0x00A6, AR2020_REG_VALUE_16BIT },
    { 0x427C, 0xF013, AR2020_REG_VALUE_16BIT },
    { 0x427E, 0xB283, AR2020_REG_VALUE_16BIT },
    { 0x4280, 0x9C36, AR2020_REG_VALUE_16BIT },
    { 0x4282, 0x00F0, AR2020_REG_VALUE_16BIT },
    { 0x4284, 0x0636, AR2020_REG_VALUE_16BIT },
    { 0x4286, 0x009C, AR2020_REG_VALUE_16BIT },
    { 0x4288, 0xF008, AR2020_REG_VALUE_16BIT },
    { 0x428A, 0x8BF0, AR2020_REG_VALUE_16BIT },
    { 0x428C, 0x0083, AR2020_REG_VALUE_16BIT },
    { 0x4290, 0x0630, AR2020_REG_VALUE_16BIT },
    { 0x4292, 0x18F0, AR2020_REG_VALUE_16BIT },
    { 0x4294, 0x02A3, AR2020_REG_VALUE_16BIT },
    { 0x4296, 0xF000, AR2020_REG_VALUE_16BIT },
    { 0x4298, 0xA3F0, AR2020_REG_VALUE_16BIT },
    { 0x429A, 0x0243, AR2020_REG_VALUE_16BIT },
    { 0x429C, 0x00F0, AR2020_REG_VALUE_16BIT },
    { 0x429E, 0x049D, AR2020_REG_VALUE_16BIT },
    { 0x42A0, 0xF078, AR2020_REG_VALUE_16BIT },
    { 0x42A2, 0x3018, AR2020_REG_VALUE_16BIT },
    { 0x42A4, 0xF000, AR2020_REG_VALUE_16BIT },
    { 0x42A6, 0x9D82, AR2020_REG_VALUE_16BIT },
    { 0x42A8, 0xF000, AR2020_REG_VALUE_16BIT },
    { 0x42AA, 0x9030, AR2020_REG_VALUE_16BIT },
    { 0x42AC, 0xC0F0, AR2020_REG_VALUE_16BIT },
    { 0x42AE, 0x1130, AR2020_REG_VALUE_16BIT },
    { 0x42B0, 0xC0F0, AR2020_REG_VALUE_16BIT },
    { 0x42B2, 0x0082, AR2020_REG_VALUE_16BIT },
    { 0x42B4, 0xF001, AR2020_REG_VALUE_16BIT },
    { 0x42B6, 0x1009, AR2020_REG_VALUE_16BIT },
    { 0x42B8, 0xF02A, AR2020_REG_VALUE_16BIT },
    { 0x42BA, 0xA2F0, AR2020_REG_VALUE_16BIT },
    { 0x42BC, 0x00A2, AR2020_REG_VALUE_16BIT },
    { 0x42BE, 0x3018, AR2020_REG_VALUE_16BIT },
    { 0x42C0, 0xF007, AR2020_REG_VALUE_16BIT },
    { 0x42C2, 0x9DF0, AR2020_REG_VALUE_16BIT },
    { 0x42C4, 0x1C8C, AR2020_REG_VALUE_16BIT },
    { 0x42C6, 0xF005, AR2020_REG_VALUE_16BIT },
    { 0x42C8, 0x301F, AR2020_REG_VALUE_16BIT },
    { 0x42CA, 0x216D, AR2020_REG_VALUE_16BIT },
    { 0x42CC, 0x0A51, AR2020_REG_VALUE_16BIT },
    { 0x42CE, 0x1FEA, AR2020_REG_VALUE_16BIT },
    { 0x42D0, 0x8640, AR2020_REG_VALUE_16BIT },
    { 0x42D2, 0xE29F, AR2020_REG_VALUE_16BIT },
    { 0x42D4, 0xF009, AR2020_REG_VALUE_16BIT },
    { 0x42D6, 0x0005, AR2020_REG_VALUE_16BIT },
    { 0x42D8, 0xF000, AR2020_REG_VALUE_16BIT },
    { 0x42DA, 0x30C0, AR2020_REG_VALUE_16BIT },
    { 0x42DC, 0xF001, AR2020_REG_VALUE_16BIT },
    { 0x42DE, 0x83F0, AR2020_REG_VALUE_16BIT },
    { 0x42E0, 0x0036, AR2020_REG_VALUE_16BIT },
    { 0x42E2, 0x00F0, AR2020_REG_VALUE_16BIT },
    { 0x42E4, 0x0087, AR2020_REG_VALUE_16BIT },
    { 0x42E6, 0xF007, AR2020_REG_VALUE_16BIT },
    { 0x42E8, 0x87F0, AR2020_REG_VALUE_16BIT },
    { 0x42EA, 0x0036, AR2020_REG_VALUE_16BIT },
    { 0x42EC, 0xC0F0, AR2020_REG_VALUE_16BIT },
    { 0x42EE, 0x0000, AR2020_REG_VALUE_16BIT },
    { 0x42F0, 0x0DF0, AR2020_REG_VALUE_16BIT },
    { 0x42F2, 0x0000, AR2020_REG_VALUE_16BIT },
    { 0x42F4, 0x05F0, AR2020_REG_VALUE_16BIT },
    { 0x42F6, 0x0030, AR2020_REG_VALUE_16BIT },
    { 0x42F8, 0xC0F0, AR2020_REG_VALUE_16BIT },
    { 0x42FA, 0x0183, AR2020_REG_VALUE_16BIT },
    { 0x42FC, 0xF000, AR2020_REG_VALUE_16BIT },
    { 0x42FE, 0x3600, AR2020_REG_VALUE_16BIT },
    { 0x4300, 0xF000, AR2020_REG_VALUE_16BIT },
    { 0x4302, 0x87F0, AR2020_REG_VALUE_16BIT },
    { 0x4304, 0x0787, AR2020_REG_VALUE_16BIT },
    { 0x4306, 0xF000, AR2020_REG_VALUE_16BIT },
    { 0x4308, 0x36C0, AR2020_REG_VALUE_16BIT },
    { 0x430A, 0xF000, AR2020_REG_VALUE_16BIT },
    { 0x430C, 0x000F, AR2020_REG_VALUE_16BIT },
    { 0x430E, 0xF42A, AR2020_REG_VALUE_16BIT },
    { 0x4310, 0x4180, AR2020_REG_VALUE_16BIT },
    { 0x4312, 0x1300, AR2020_REG_VALUE_16BIT },
    { 0x4314, 0x9FF0, AR2020_REG_VALUE_16BIT },
    { 0x4316, 0x00E0, AR2020_REG_VALUE_16BIT },
    { 0x4318, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x431A, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x431C, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x431E, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x4320, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x4322, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x4324, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x4326, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x4328, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x432A, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x432C, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x432E, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x4330, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x4332, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x4334, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x4336, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x4338, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x433A, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x433C, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x433E, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x4340, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x4342, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x4344, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x4346, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x4348, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x434A, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x434C, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x434E, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x4350, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x4352, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x4354, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x4356, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x4358, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x435A, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x435C, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x435E, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x4360, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x4362, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x4364, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x4366, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x4368, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x436A, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x436C, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x436E, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x4370, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x4372, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x4374, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x4376, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x4378, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x437A, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x437C, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x437E, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x4380, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x4382, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x4384, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x4386, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x4388, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x438A, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x438C, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x438E, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x4390, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x4392, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x4394, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x4396, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x4398, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x439A, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x439C, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x439E, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x43A0, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x43A2, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x43A4, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x43A6, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x43A8, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x43AA, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x43AC, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x43AE, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x43B0, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x43B2, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x43B4, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x43B6, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x43B8, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x43BA, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x43BC, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x43BE, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x43C0, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x43C2, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x43C4, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x43C6, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x43C8, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x43CA, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x43CC, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x43CE, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x43D0, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x43D2, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x43D4, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x43D6, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x43D8, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x43DA, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x43DC, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x43DE, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x43E0, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x43E2, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x43E4, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x43E6, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x43E8, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x43EA, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x43EC, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x43EE, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x43F0, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x43F2, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x43F4, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x43F6, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x43F8, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x43FA, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x43FC, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x43FE, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x4400, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x4402, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x4404, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x4406, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x4408, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x440A, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x440C, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x440E, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x4410, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x4412, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x4414, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x4416, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x4418, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x441A, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x441C, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x441E, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x4420, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x4422, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x4424, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x4426, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x4428, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x442A, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x442C, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x442E, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x4430, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x4432, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x4434, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x4436, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x4438, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x443A, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x443C, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x443E, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x4440, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x4442, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x4444, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x4446, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x4448, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x444A, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x444C, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x444E, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x4450, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x4452, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x4454, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x4456, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x4458, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x445A, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x445C, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x445E, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x4460, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x4462, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x4464, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x4466, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x4468, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x446A, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x446C, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x446E, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x4470, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x4472, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x4474, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x4476, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x4478, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x447A, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x447C, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x447E, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x4480, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x4482, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x4484, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x4486, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x4488, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x448A, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x448C, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x448E, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x4490, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x4492, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x4494, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x4496, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x4498, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x449A, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x449C, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x449E, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x44A0, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x44A2, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x44A4, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x44A6, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x44A8, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x44AA, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x44AC, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x44AE, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x44B0, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x44B2, 0xE0E0, AR2020_REG_VALUE_16BIT },
    { 0x44B4, 0xE0E0, AR2020_REG_VALUE_16BIT },
    /* --- END TIMING ANALOG RECOMMEND POR --- */
    { REG_DELAY, 1000, AR2020_REG_VALUE_16BIT },

    /* --- ANALOG RECOMMENDED SETTING --- */
    { 0x44BA, 0x0050, AR2020_REG_VALUE_16BIT },     /* [0x44BA] DAC_LD_4_5   = 0x0050   (ecl for lcg = 72, hcg_fsc = 0) */
    { 0x44BC, 0xBCAA, AR2020_REG_VALUE_16BIT },     /* [0x44BC] DAC_LD_6_7   = 0xBCAA */
    { 0x44C0, 0x4070, AR2020_REG_VALUE_16BIT },     /* [0x44C0] DAC_LD_10_11 = 0x4070   (txlo1_clk_gate_en=1, pnc_ibias_lcg=112) */
    { 0x44C4, 0x04D0, AR2020_REG_VALUE_16BIT },     /* [0x44C4] DAC_LD_14_15 = 0x04D0   (ecl for hcg = 80) */
    { 0x44C6, 0x17E2, AR2020_REG_VALUE_16BIT },     /* [0x44C6] DAC_LD_16_17 = 0x17E2   (adc_pwedn_en=1, azbias_ctrl=7) */
    { 0x44C8, 0xEA43, AR2020_REG_VALUE_16BIT },     /* [0x44C8] DAC_LD_18_19 = 0xEA43   (rs_hi for lcg = 10, for hcg low gain = 4) */
    { 0x44CA, 0x000E, AR2020_REG_VALUE_16BIT },     /* [0x44CA] DAC_LD_20_21 = 0x000E   (pcn_ibias_hcg = 0) */
    { 0x44CC, 0x7777, AR2020_REG_VALUE_16BIT },     /* [0x44CC] DAC_LD_22_23 = 0x7777   (txlo level = 0x7777) */
    { 0x44CE, 0x8BA4, AR2020_REG_VALUE_16BIT },     /* [0x44CE] DAC_LD_24_25 = 0x8BA4   (tx hi = 4, dcg_hi = 10, VAA = 3.6V) */
    { 0x44D0, 0x1735, AR2020_REG_VALUE_16BIT },     /* [0x44D0] DAC_LD_26_27 = 0x1735   (pnc_disable = 0, rampbuf_sel = 1) */
    { 0x44D2, 0x0B87, AR2020_REG_VALUE_16BIT },     /* [0x44D2] DAC_LD_28_29 = 0x0B87   (rs_hi_cloop_en = 1, txlo_en_1 = 1) */
    { 0x44D4, 0x0000, AR2020_REG_VALUE_16BIT },     /* [0x44D4] DAC_LD_30_31 = 0x0000   (pnc_ibias_hcg_off = 0) */
    { 0x44D6, 0xF206, AR2020_REG_VALUE_16BIT },     /* [0x44D6] DAC_LD_32_33 = 0xF206   (dcg_vaa_en = 1) */
    { 0x44D8, 0xAAFA, AR2020_REG_VALUE_16BIT },     /* [0x44D8] DAC_LD_34_35 = 0xAAFA   (clk_div_tx = 2, cap_sel = 2) */
    { 0x44DA, 0xE001, AR2020_REG_VALUE_16BIT },     /* [0x44DA] DAC_LD_36_37 = 0xE001   (pnc_sf_lcg = 7) */
    { 0x44DE, 0x9BBC, AR2020_REG_VALUE_16BIT },     /* [0x44DE] DAC_LD_40_41 = 0x9BBC   (rst_under = 60, ramp_delay = 27) */
    { 0x44E0, 0x283C, AR2020_REG_VALUE_16BIT },     /* [0x44E0] DAC_LD_42_43 = 0x283C   (sig_under = 60, rst_over = 40) */
    { 0x44E2, 0x2821, AR2020_REG_VALUE_16BIT },     /* [0x44E2] DAC_LD_44_45 = 0x2821   (sig_over = 40, reduce_colsel_en = 1) */
    { 0x44E4, 0x8000, AR2020_REG_VALUE_16BIT },     /* [0x44E4] DAC_LD_46_47 = 0x8000 */
    { 0x44E6, 0x503F, AR2020_REG_VALUE_16BIT },     /* [0x44E6] DAC_LD_48_49 = 0x503F   (rs_hi_hcg_high_gain = 6) */
    { 0x32A4, 0x0000, AR2020_REG_VALUE_16BIT },     /* [0x32A4] RESERVED_MFR_32A4 = 0x0000   (crm on) */
    { 0x328E, 0x0004, AR2020_REG_VALUE_16BIT },     /* [0x328E] ADDR_CTRL         = 0x0004   (integration_update_next_frame = 1) */
    { 0x333C, 0x0001, AR2020_REG_VALUE_16BIT },     /* [0x333C] DYNAMIC_CTRL      = 0x0001   (of_init = 1) */
  
    { 0x301A, 0x0000, AR2020_REG_VALUE_16BIT },     /* Unlock  */
    { 0x3600, 0x94DF, AR2020_REG_VALUE_16BIT },     /* [0x3600] RESERVED_MFR_3600 = 0x94DF   (Enable fdoc) */
    { 0x3616, 0x0000, AR2020_REG_VALUE_16BIT },     /* [0x3616] FDOC_CTRL2 = 0x0000   (Disable fdoc_bw_mode_en) */
    { 0x3700, 0x0001, AR2020_REG_VALUE_16BIT },     /* [0x3700] PIX_DEF_ID = 0x0001   (Enable pixel defect) */
    { 0x3980, 0x0003, AR2020_REG_VALUE_16BIT },     /* [0x3980] PIX_DEF_CORR = 0x0003   (Enable pixel defect) */
    { 0x36C0, 0x0001, AR2020_REG_VALUE_16BIT },     /* [0x36C0] DIGITAL_GAIN_CTRL = 0x0001   (Enable dither) */
    { 0x36DE, 0x002A, AR2020_REG_VALUE_16BIT },     /* [0x36DE] DATA_PEDESTAL1 = 0x002A   (Set pedestal = 42) */
    { 0x301A, 0x0008, AR2020_REG_VALUE_16BIT },     /* Lock  */
    /* SRGB Full resolution  */
    { 0x3060, 0x0000, AR2020_REG_VALUE_16BIT },     /* [0x3060] GAIN_TABLE_CTRL = 0x0000  */
    { 0x3982, 0xAC70, AR2020_REG_VALUE_16BIT },     /* [0x3982] PIX_DEF_LUT_DATA[0] = 0xAC70 */
    { 0x3984, 0xFA98, AR2020_REG_VALUE_16BIT },     /* [0x3984] PIX_DEF_LUT_DATA[1] = 0xFA98 */
    { 0x3986, 0xFC3F, AR2020_REG_VALUE_16BIT },     /* [0x3986] PIX_DEF_LUT_DATA[2] = 0xFC3F */
    { 0x3988, 0xAC70, AR2020_REG_VALUE_16BIT },     /* [0x3988] PIX_DEF_LUT_DATA[3] = 0xAC70 */
    { 0x398A, 0xFA98, AR2020_REG_VALUE_16BIT },     /* [0x398A] PIX_DEF_LUT_DATA[4] = 0xFA98 */
    { 0x398C, 0xFC3F, AR2020_REG_VALUE_16BIT },     /* [0x398C] PIX_DEF_LUT_DATA[5] = 0xFC3F */
    { 0x3980, 0x0003, AR2020_REG_VALUE_16BIT },     /* [0x3980] PIX_DEF_CORR = 0x0003   (Enable pixel defect correction) */

    { REG_DELAY, 1000, AR2020_REG_VALUE_16BIT },
    { 0x3060, 0xFF01, AR2020_REG_VALUE_16BIT },     /* [0x3060] GAIN_TABLE_CTRL = 0xFF01 */
    /* --- END ANALOG RECOMMENDED SETTING --- */
    // { 0x3340, 0x0800, AR2020_REG_VALUE_16BIT },   /* [0x3340] OTPM_USER_POWERDOWN bit = 0x0800 */
    // { 0x3340, 0x1000, AR2020_REG_VALUE_16BIT },   /* [0x3340] OTPM_REGULATOR_PD bit  = 0x1000 */
    { REG_NULL, 0x0000, AR2020_REG_VALUE_16BIT }
};

/* Supported sensor mode configurations */
static const struct ar2020_mode supported_modes[] = {
    {
        .width = 4096,
        .height = 3840,
        .max_fps = { .numerator = 511, .denominator = 100 }, // = 11 FPS
        .hts_def = 0xFFF0,      /* LINE_LENGTH_PCK = 21104 */
        .vts_def = 0x1FC4,      /* FRAME_LENGTH_LINES = 3854 */
        .hblank  = 19226,       //---------------
        .vblank  = 2774,
        .vblank_min = 16, 
        .vblank_max = 0xFFFF,   //---------------
        .exp_def = 0x0003 + 100, 
        .pclk = 100466688,        /* 22.8096 MHz */
	    .link_freq_idx = 0,
        .code = MEDIA_BUS_FMT_SGRBG10_1X10,
        .reg_list = MIPI_2lane__5120x3840_Linear_7p5fps,
    }
};

static const char * const ar2020_test_pattern_menu[] = {
	"Disabled",
	"Solid Color",
	"Color Bars",
	"Fade to Grey Bars",
	"PN9 Link Integrity",
	"100% Color Tile",
    "Marching 1s"
};

/* Register Access Functions */
static int ar2020_read_reg(struct i2c_client *client, u16 reg, u8 len, u32 *val)
{
    struct i2c_msg msgs[2];
    u8 addr_buf[2] = { reg >> 8, reg & 0xFF };
    u8 data_buf[2] = { 0 };
    int ret;

    msgs[0].addr = client->addr;
    msgs[0].flags = 0;
    msgs[0].len = 2;
    msgs[0].buf = addr_buf;

    msgs[1].addr = client->addr;
    msgs[1].flags = I2C_M_RD;
    msgs[1].len = len;
    msgs[1].buf = data_buf;

    ret = i2c_transfer(client->adapter, msgs, 2);
    if (ret != 2) {
        dev_err(&client->dev, "Failed to read reg 0x%04x: %d\n", reg, ret);
        return -EIO;
    }

    *val = (len == AR2020_REG_VALUE_16BIT) ? (data_buf[0] << 8) | data_buf[1] : data_buf[0];
    return 0;
}

static int ar2020_write_reg(struct i2c_client *client, u16 reg, u8 len, u16 val)
{
    struct i2c_msg msg;
    u8 buf[4];
    int ret;

    buf[0] = reg >> 8;
    buf[1] = reg & 0xFF;
    if (len == AR2020_REG_VALUE_08BIT) {
        buf[2] = val & 0xFF;
    } else {
        buf[2] = val >> 8;
        buf[3] = val & 0xFF;
    }

    msg.addr = client->addr;
    msg.flags = 0;
    msg.len = (len == AR2020_REG_VALUE_08BIT) ? 3 : 4;
    msg.buf = buf;

    ret = i2c_transfer(client->adapter, &msg, 1);
    if (ret != 1) {
        dev_err(&client->dev, "Failed to write reg 0x%04x: %d\n", reg, ret);
        return -EIO;
    }
    return 0;
}

static int ar2020_write_array(struct i2c_client *client, const struct regval *regs)
{
    int ret = 0;
    while (regs->addr != REG_NULL) {
        if (regs->addr == REG_DELAY) {
            usleep_range(regs->val, regs->val + 100);
        } else {
            ret = ar2020_write_reg(client, regs->addr, regs->bits, regs->val);
            if (ret)
                return ret;
        }
        regs++;
    }
    return 0;
}

/* Helper function to apply custom register settings */
static int ar2020_apply_custom_regs(struct ar2020 *ar2020)
{
    int ret = 0;
    for (int i = 0; i < AR2020_MAX_CUSTOM_REGS; i++) {
        if (ar2020->custom_regs_array[i].enabled) {
            ret = ar2020_write_reg(ar2020->client,
                                   ar2020->custom_regs_array[i].addr,
                                   ar2020->custom_regs_array[i].bits,
                                   ar2020->custom_regs_array[i].val);
            if (ret) {
                dev_err(&ar2020->client->dev,
                        "Failed to set custom reg 0x%04x to 0x%04x: %d\n",
                        ar2020->custom_regs_array[i].addr,
                        ar2020->custom_regs_array[i].val, ret);
                return ret;
            }
            dev_info(&ar2020->client->dev,
                     "Set custom reg 0x%04x = 0x%04x\n",
                     ar2020->custom_regs_array[i].addr,
                     ar2020->custom_regs_array[i].val);
        }
    }
    return 0;
}

/* Sensor Initialization */
static int ar2020_check_sensor_id(struct ar2020 *ar2020)
{
    u32 id = 0;
    int ret;

    ret = ar2020_read_reg(ar2020->client, AR2020_REG_CHIP_ID, AR2020_REG_VALUE_16BIT, &id);
    if (ret) {
        dev_err(&ar2020->client->dev, "Failed to read chip ID\n");
        return ret;
    }
    if (id != CHIP_ID) {
        dev_err(&ar2020->client->dev, "Wrong chip ID: 0x%04x (expected 0x%04x)\n", id, CHIP_ID);
        return -ENODEV;
    }
    dev_info(&ar2020->client->dev, "Detected AR2020 chip ID: 0x%04x\n", id);
    return 0;
}

/* Power Management */
static int __ar2020_power_on(struct device *dev)
{
	struct v4l2_subdev *sd = dev_get_drvdata(dev);
	struct ar2020 *ar2020 = to_ar2020(sd);
	int ret;

    dev_info(ar2020->dev, "ar2020 Calling PowerOn - Kernel Module [3.0.0]");

    ret = clk_set_rate(ar2020->xvclk, AR2020_XVCLK_FREQ);
    if (ret)
        dev_warn(ar2020->dev, "Failed to set xvclk rate\n");
    ret = clk_prepare_enable(ar2020->xvclk);
    if (ret) {
        dev_err(ar2020->dev, "Failed to enable xvclk\n");
        return ret;
    }
    dev_info(ar2020->dev, "ar2020 Done PowerOnStep Without ERROR");
    return 0;
}

static int __ar2020_power_off(struct device *dev)
{
    struct v4l2_subdev *sd = dev_get_drvdata(dev);
	struct ar2020 *ar2020 = to_ar2020(sd);
    clk_disable_unprepare(ar2020->xvclk);
    return 0;
}

static int ar2020_update_controls(struct ar2020 *ar2020,
				  const struct ar2020_mode *mode)
{
	int ret;

	ret = __v4l2_ctrl_s_ctrl(ar2020->link_freq_ctrl, mode->link_freq_idx);
	if (ret)
		return ret;

//	ret = __v4l2_ctrl_s_ctrl(ar2020->hblank_ctrl, mode->hblank);
//	if (ret)
//		return ret;

//	return __v4l2_ctrl_modify_range(ar2020->vblank_ctrl, mode->vblank_min,
//					mode->vblank_max, 1, mode->vblank);
	return ret;
}

/* V4L2 Controls */
static int ar2020_s_ctrl(struct v4l2_ctrl *ctrl)
{
    struct ar2020 *ar2020 =
        container_of(ctrl->handler, struct ar2020, ctrl_handler);
    struct i2c_client *client = ar2020->client;
    int ret = 0;
    u16 tp_mode = 0;

    /* If sensor is (power off), do nothing */
    if (!pm_runtime_get_if_in_use(&client->dev))
        return 0;

    switch (ctrl->id) {
    case V4L2_CID_EXPOSURE:
        ret = ar2020_write_reg(client, 0x0202, /* COARSE_INTEGRATION_TIME */
                               AR2020_REG_VALUE_16BIT, ctrl->val);
        if (ret)
            dev_err(&client->dev, "Failed to set exposure: %d\n", ret);
        break;

    case V4L2_CID_ANALOGUE_GAIN:
        ret = ar2020_write_reg(client, 0x3062, /* ANALOGUE_GAIN */
                               AR2020_REG_VALUE_16BIT, ctrl->val);
        if (ret)
            dev_err(&client->dev, "Failed to set gain: %d\n", ret);
        break;

    case V4L2_CID_VBLANK:
        ret = ar2020_write_reg(client, 0x0340, /* FRAME_LENGTH_LINES */
                               AR2020_REG_VALUE_16BIT,
                               ar2020->cur_mode->height + ctrl->val);
        if (ret)
            dev_err(&client->dev, "Failed to set vblank: %d\n", ret);
        break;

    case V4L2_CID_HBLANK:
        /* HBLANK read-only. */
        break;

    case V4L2_CID_TEST_PATTERN:
        if (ctrl->val == 0) {
            tp_mode = 0x0000; // Disable
        } else if (ctrl->val == 6) {
            tp_mode = 0x0100; // Marching 1s test pattern
        } else {
            tp_mode = ctrl->val & 0x7; // Only bits 2:0, no bit 8
        }
        ret = ar2020_write_reg(client, 0x0600, AR2020_REG_VALUE_16BIT, tp_mode);
        if (ret)
            break;
        if (ctrl->val == 1) {
            ar2020_write_reg(client, 0x0602, AR2020_REG_VALUE_16BIT, 0x03FF); // TEST_DATA_RED
            // Thêm các giá trị khác nếu cần
        }
        break;

    case V4L2_CID_AR2020_SET_REGISTER:
    {
        const char *str = ctrl->p_new.p_char;
        u16 addr, val;
        u8 bits;
        int index = -1;

        /* Skip if string is empty or NULL */
        if (!str || !str[0]) {
            dev_dbg(&client->dev, "Skipping empty custom register control\n");
            break;
        }

        /* Parse format: 0xADDR=0xVALUE:BITS */
        if (sscanf(str, "0x%hx=0x%hx:%hhu", &addr, &val, &bits) != 3) {
            dev_err(&client->dev, "Invalid register format: %s (expected 0xADDR=0xVALUE:BITS)\n", str);
            ret = -EINVAL;
            break;
        }

        if (bits != 8 && bits != 16) {
            dev_err(&client->dev, "Invalid bit width: %u (must be 8 or 16)\n", bits);
            ret = -EINVAL;
            break;
        }

        for (int i = 0; i < AR2020_MAX_CUSTOM_REGS; i++) {
            if (!ar2020->custom_regs_array[i].enabled) {
                index = i;
                break;
            }
            if (ar2020->custom_regs_array[i].addr == addr) {
                index = i;
                break;
            }
        }

        if (index < 0) {
            dev_err(&client->dev, "No space for new custom register\n");
            ret = -ENOMEM;
            break;
        }

        ar2020->custom_regs_array[index].addr = addr;
        ar2020->custom_regs_array[index].val = val;
        ar2020->custom_regs_array[index].bits = (bits == 8) ? AR2020_REG_VALUE_08BIT : AR2020_REG_VALUE_16BIT;
        ar2020->custom_regs_array[index].enabled = true;

        dev_info(&client->dev, "Stored custom reg 0x%04x = 0x%04x, %d-bit\n", addr, val, bits);
        break;
    }

    case V4L2_CID_AR2020_CLEAR_CUSTOM_REGS:
    {
        const char *str = ctrl->p_new.p_char;
        u16 addr;
        bool cleared = false;

        /* Skip if string is empty or NULL */
        if (!str || !str[0]) {
            dev_dbg(&client->dev, "Skipping empty clear custom registers control\n");
            break;
        }

        if (!strcmp(str, "all")) {
            for (int i = 0; i < AR2020_MAX_CUSTOM_REGS; i++) {
                ar2020->custom_regs_array[i].enabled = false;
            }
            dev_info(&client->dev, "Cleared all custom registers\n");
            cleared = true;
        } else if (sscanf(str, "0x%hx", &addr) == 1) {
            for (int i = 0; i < AR2020_MAX_CUSTOM_REGS; i++) {
                if (ar2020->custom_regs_array[i].enabled &&
                    ar2020->custom_regs_array[i].addr == addr) {
                    ar2020->custom_regs_array[i].enabled = false;
                    dev_info(&client->dev, "Cleared custom reg 0x%04x\n", addr);
                    cleared = true;
                    break;
                }
            }
        } else {
            dev_err(&client->dev, "Invalid clear format: %s (use 'all' or '0xADDR')\n", str);
            ret = -EINVAL;
            break;
        }

        if (!cleared && strcmp(str, "all")) {
            dev_warn(&client->dev, "No custom reg 0x%04x found to clear\n", addr);
        }
        break;
    }
    
    default:
        ret = -EINVAL;
        dev_err(&client->dev, "Invalid control %d", ctrl->id);
        break;
    }

    pm_runtime_put(&client->dev);
    return ret;
}

/* V4l2 subdevice control ops*/
static const struct v4l2_ctrl_ops ar2020_ctrl_ops = {
    .s_ctrl = ar2020_s_ctrl,
};

/* Subdev Operations */
static int ar2020_enum_mbus_code(struct v4l2_subdev *sd,
                                 struct v4l2_subdev_state *sd_state,
                                 struct v4l2_subdev_mbus_code_enum *code)
{
    if (code->index > 0)
        return -EINVAL;
    code->code = MEDIA_BUS_FMT_SGRBG10_1X10; // RAW10 MEDIA_BUS_FMT_SGRBG10_1X10
    return 0;
}

static int ar2020_enum_frame_size(struct v4l2_subdev *sd,
				  struct v4l2_subdev_state *sd_state,
				  struct v4l2_subdev_frame_size_enum *fsize)
{
	if (fsize->index > 0)
		return -EINVAL;

	if (fsize->code != supported_modes[0].code)
		return -EINVAL;

	fsize->min_width = supported_modes[0].width;
	fsize->max_width = fsize->min_width;
	fsize->min_height = supported_modes[0].height;
	fsize->max_height = fsize->min_height;

	return 0;
}

static void ar2020_fill_pad_format(struct ar2020 *ar2020,
				   const struct ar2020_mode *mode,
				   struct v4l2_subdev_format *fmt)
{
	fmt->format.width = mode->width;
	fmt->format.height = mode->height;
	fmt->format.code = mode->code;
	fmt->format.field = V4L2_FIELD_NONE;
	fmt->format.colorspace = V4L2_COLORSPACE_RAW;
	fmt->format.ycbcr_enc = V4L2_YCBCR_ENC_DEFAULT;
	fmt->format.quantization = V4L2_QUANTIZATION_DEFAULT;
	fmt->format.xfer_func = V4L2_XFER_FUNC_NONE;
}

static int ar2020_get_pad_format(struct v4l2_subdev *sd,
				 struct v4l2_subdev_state *sd_state,
				 struct v4l2_subdev_format *fmt)
{
	struct ar2020 *ar2020 = to_ar2020(sd);

	mutex_lock(&ar2020->mutex);

	if (fmt->which == V4L2_SUBDEV_FORMAT_TRY) {
		struct v4l2_mbus_framefmt *framefmt;

		framefmt = v4l2_subdev_get_try_format(sd, sd_state, fmt->pad);
		fmt->format = *framefmt;
	} else {
		ar2020_fill_pad_format(ar2020, ar2020->cur_mode, fmt);
	}

	mutex_unlock(&ar2020->mutex);

	return 0;
}

static int ar2020_s_power(struct v4l2_subdev *sd, int on)
{
    struct ar2020 *ar2020 = to_ar2020(sd);
    int ret = 0;

    mutex_lock(&ar2020->mutex);

    if (on) {
        ret = __ar2020_power_on(ar2020->dev);
    } else {
        __ar2020_power_off(ar2020->dev);
    }

    mutex_unlock(&ar2020->mutex);
    return ret;
}

static const struct v4l2_subdev_core_ops ar2020_core_ops = {
    .s_power = ar2020_s_power,  
};

static int ar2020_link_setup(struct media_entity *entity,
                             const struct media_pad *local,
                             const struct media_pad *remote,
                             u32 flags)
{
    return 0; // Dummy, always success
}

static const struct media_entity_operations ar2020_entity_ops = {
    .link_setup = ar2020_link_setup,
};

static int ar2020_set_pad_format(struct v4l2_subdev *sd,
                          struct v4l2_subdev_state *sd_state,
                          struct v4l2_subdev_format *fmt)
{
	struct ar2020 *ar2020 = to_ar2020(sd);
	const struct ar2020_mode *mode;
	int ret = 0;

    mutex_lock(&ar2020->mutex);
    mode = &supported_modes[0];
	ar2020_fill_pad_format(ar2020, mode, fmt);

	if (fmt->which == V4L2_SUBDEV_FORMAT_TRY) {
		struct v4l2_mbus_framefmt *framefmt;
		framefmt = v4l2_subdev_get_try_format(sd, sd_state, fmt->pad);
		*framefmt = fmt->format;
        dev_info(&ar2020->client->dev, "Set pad format with V4L2_SUBDEV_FORMAT_TRY\n");
	} else {
        dev_info(&ar2020->client->dev, "Set pad format with ar2020_update_controls\n");
		ret = ar2020_update_controls(ar2020, mode);
		if (!ret)
			ar2020->cur_mode = mode;
	}

	mutex_unlock(&ar2020->mutex);

	return ret;
}

static int ar2020_init_pad_cfg(struct v4l2_subdev *sd,
			       struct v4l2_subdev_state *sd_state)
{
	struct ar2020 *ar2020 = to_ar2020(sd);
	struct v4l2_subdev_format fmt = { 0 };
	fmt.which = sd_state ? V4L2_SUBDEV_FORMAT_TRY : V4L2_SUBDEV_FORMAT_ACTIVE;
	ar2020_fill_pad_format(ar2020, &supported_modes[0], &fmt);
    dev_info(&ar2020->client->dev, "Initialize Pad Configuration!\n");
	return ar2020_set_pad_format(sd, sd_state, &fmt);
}

/* Streaming */
static int __ar2020_start_stream(struct ar2020 *ar2020)
{
    int ret;
    u32 val;

    dev_info(&ar2020->client->dev, "Starting stream\n");
    /* Delay to allow the sensor enough time to power up. */
    // mdelay(1);
    ret = ar2020_write_array(ar2020->client, ar2020->cur_mode->reg_list);
    if (ret) {
        dev_err(&ar2020->client->dev, "Failed to write register array: %d\n", ret);
        return ret;
    }

    /* Confirm that  MIPI 2-lane */
    ret = ar2020_read_reg(ar2020->client, 0x0114, AR2020_REG_VALUE_08BIT, &val);
    if (ret) {
        dev_err(&ar2020->client->dev, "Failed to read CSI_LANE_MODE: %d\n", ret);
        return ret;
    }
    if (val != 0x01) {
        dev_err(&ar2020->client->dev, "CSI_LANE_MODE is 0x%02x, expected 0x01\n", val);
    } else {
        dev_info(&ar2020->client->dev, "CSI_LANE_MODE confirmed as 2-lane (0x01)\n");
    }

    /* Now will init v4l2 for camera control */
    ret = __v4l2_ctrl_handler_setup(&ar2020->ctrl_handler);
    if (ret) {
        dev_err(&ar2020->client->dev, "Failed to setup controls: %d\n", ret);
        return ret;
    }

    /* Apply custom register settings */
    ret = ar2020_apply_custom_regs(ar2020);
    if (ret) {
        dev_err(&ar2020->client->dev, "Failed to apply custom registers: %d\n", ret);
        return ret;
    }    

    ret = ar2020_write_reg(ar2020->client, AR2020_REG_CTRL_MODE,
                           AR2020_REG_VALUE_08BIT, AR2020_MODE_STREAMING);
    if (ret) {
        dev_err(&ar2020->client->dev, "Failed to start streaming: %d\n", ret);
        return ret;
    }

    // usleep_range(10000, 20000); // 10 to 20ms
    // ret = ar2020_read_reg(ar2020->client, 0x0005, AR2020_REG_VALUE_08BIT, &val);
    // if (ret) {
    //     dev_err(&ar2020->client->dev, "Failed to read FRAME_COUNT\n");
    //     return ret;
    // }
    // dev_info(&ar2020->client->dev, "FRAME_COUNT after streaming: 0x%02x\n", val);

    return 0;
}

static int __ar2020_stop_stream(struct ar2020 *ar2020)
{
    return ar2020_write_reg(ar2020->client, AR2020_REG_CTRL_MODE,
                            AR2020_REG_VALUE_08BIT, AR2020_MODE_SW_STANDBY);
}

static int ar2020_s_stream(struct v4l2_subdev *sd, int enable)
{
    struct ar2020 *ar2020 = to_ar2020(sd);
    int ret = 0;

    mutex_lock(&ar2020->mutex);
    if (ar2020->streaming == enable){
		mutex_unlock(&ar2020->mutex);
		return 0;
	}

    if (enable) {
		ret = pm_runtime_resume_and_get(ar2020->dev);
		if (ret)
			goto error_unlock;

        ret = __ar2020_start_stream(ar2020);
        if (ret) {
            dev_err(&ar2020->client->dev, "Stream start failed: %d\n", ret);
            goto error_power_off;
        }
        dev_info(&ar2020->client->dev, "Stream started\n");
    } else {
        ret = __ar2020_stop_stream(ar2020);
        if (ret)
            dev_err(&ar2020->client->dev, "Stream stop failed: %d\n", ret);
        pm_runtime_put(ar2020->dev);
        dev_info(&ar2020->client->dev, "Stream stopped\n");
    }
    ar2020->streaming = enable;


error_power_off:
	pm_runtime_put(ar2020->dev);
error_unlock:
	mutex_unlock(&ar2020->mutex);

	return ret;
}

static int ar2020_parse_hw_config(struct ar2020 *ar2020)
{
	struct fwnode_handle *fwnode = dev_fwnode(ar2020->dev);
	struct v4l2_fwnode_endpoint bus_cfg = {
		.bus_type = V4L2_MBUS_CSI2_DPHY
	};
	struct fwnode_handle *ep;
	unsigned int i;
	int ret;

	if (!fwnode)
		return -ENXIO;

	ep = fwnode_graph_get_next_endpoint(fwnode, NULL);
	if (!ep)
		return -ENXIO;

	ret = v4l2_fwnode_endpoint_alloc_parse(ep, &bus_cfg);
	fwnode_handle_put(ep);
	if (ret)
		return ret;

	if (bus_cfg.bus.mipi_csi2.num_data_lanes != AR2020_LANES) {
		dev_err(ar2020->dev,
			"Number of CSI2 data lanes %d is not supported",
			bus_cfg.bus.mipi_csi2.num_data_lanes);
		ret = -EINVAL;
		goto done_endpoint_free;
	}

	if (!bus_cfg.nr_of_link_frequencies) {
		dev_err(ar2020->dev, "No link frequencies defined");
		ret = -EINVAL;
		goto done_endpoint_free;
	}

	for (i = 0; i < bus_cfg.nr_of_link_frequencies; i++)
		if (bus_cfg.link_frequencies[i] == AR2020_LINK_FREQ)
			goto done_endpoint_free;

	ret = -EINVAL;

done_endpoint_free:
	v4l2_fwnode_endpoint_free(&bus_cfg);

	return ret;
}

static const struct v4l2_subdev_video_ops ar2020_video_ops = {
    .s_stream = ar2020_s_stream,
};

static const struct v4l2_subdev_pad_ops ar2020_pad_ops = {
    .init_cfg = ar2020_init_pad_cfg,
    .enum_mbus_code = ar2020_enum_mbus_code,
    .enum_frame_size = ar2020_enum_frame_size,
    .get_fmt = ar2020_get_pad_format,
    .set_fmt = ar2020_set_pad_format,
};

static const struct v4l2_subdev_ops ar2020_subdev_ops = {
    .core = &ar2020_core_ops,
    .video = &ar2020_video_ops,
    .pad = &ar2020_pad_ops,
};

static int ar2020_initialize_controls(struct ar2020 *ar2020)
{
    struct v4l2_ctrl_handler *handler = &ar2020->ctrl_handler;
    const struct ar2020_mode *mode = ar2020->cur_mode;
    s64 exposure_max, vblank_def;
    u32 h_blank;
    int ret;

    ret = v4l2_ctrl_handler_init(handler, 8);
    if (ret)
        return ret;

    h_blank = mode->hts_def - mode->width;
    ar2020->hblank_ctrl = v4l2_ctrl_new_std(handler, NULL, V4L2_CID_HBLANK,
                                       h_blank, h_blank, 1, h_blank);
    if (ar2020->hblank_ctrl)
        ar2020->hblank_ctrl->flags |= V4L2_CTRL_FLAG_READ_ONLY;

    vblank_def = mode->vts_def - mode->height;
    ar2020->vblank_ctrl = v4l2_ctrl_new_std(handler, &ar2020_ctrl_ops,
                                       V4L2_CID_VBLANK, vblank_def,
                                       AR2020_VTS_MAX - mode->height, 1, vblank_def);

    exposure_max = mode->vts_def - 4; // e.g: 0x1BC4 - 4 = 7104
    ar2020->exposure = v4l2_ctrl_new_std(handler, &ar2020_ctrl_ops,
                                         V4L2_CID_EXPOSURE, AR2020_EXPOSURE_MIN,
                                         exposure_max, AR2020_EXPOSURE_STEP,
                                         mode->exp_def); // exp_def = 0x0003 + 100

    ar2020->anal_gain = v4l2_ctrl_new_std(handler, &ar2020_ctrl_ops,
                                          V4L2_CID_ANALOGUE_GAIN, AR2020_GAIN_MIN,
                                          AR2020_GAIN_MAX, AR2020_GAIN_STEP,
                                          AR2020_GAIN_DEFAULT);

    ar2020->link_freq_ctrl = v4l2_ctrl_new_int_menu(handler,
							&ar2020_ctrl_ops,
							V4L2_CID_LINK_FREQ,
							ARRAY_SIZE(link_freq) -
							1,
							mode->link_freq_idx,
							link_freq);
    if (ar2020->link_freq_ctrl)
        ar2020->link_freq_ctrl->flags |= V4L2_CTRL_FLAG_READ_ONLY;

    ar2020->test_pattern = v4l2_ctrl_new_std_menu_items(handler,
                           &ar2020_ctrl_ops,
                           V4L2_CID_TEST_PATTERN,
                           ARRAY_SIZE(ar2020_test_pattern_menu) - 1,
                           0,
                           0,
                           ar2020_test_pattern_menu);

    ar2020->custom_regs = v4l2_ctrl_new_custom(handler, &(struct v4l2_ctrl_config) {
        .ops = &ar2020_ctrl_ops,
        .id = V4L2_CID_AR2020_SET_REGISTER,
        .name = "Set Custom Register",
        .type = V4L2_CTRL_TYPE_STRING,
        .flags = V4L2_CTRL_FLAG_WRITE_ONLY,
        .max = 32, /* Enough for "0xFFFF=0xFFFF,16" */
        .step = 1,
    }, NULL); 
                   
    ar2020->clear_custom_regs = v4l2_ctrl_new_custom(handler, &(struct v4l2_ctrl_config) {
        .ops = &ar2020_ctrl_ops,
        .id = V4L2_CID_AR2020_CLEAR_CUSTOM_REGS,
        .name = "Clear Custom Registers",
        .type = V4L2_CTRL_TYPE_STRING,
        .flags = V4L2_CTRL_FLAG_WRITE_ONLY,
        .max = 16, /* Enough for "all" or "0xFFFF" */
        .step = 1,
    }, NULL);

    if (handler->error) {
        ret = handler->error;
        v4l2_ctrl_handler_free(handler);
        return ret;
    }

    ar2020->sd.ctrl_handler = handler;

    ret = ar2020_s_ctrl(ar2020->exposure);
    if (ret)
        dev_err(&ar2020->client->dev, "Failed to set default exposure\n");
    ret = ar2020_s_ctrl(ar2020->anal_gain);
    if (ret)
        dev_err(&ar2020->client->dev, "Failed to set default gain\n");

    return 0;
}

/* Probe and Remove */
static int ar2020_probe(struct i2c_client *client)
{
    // struct device *dev = &client->dev;
    struct ar2020 *ar2020;
    // struct v4l2_subdev *sd;
    int ret;

    ar2020 = devm_kzalloc(&client->dev, sizeof(*ar2020), GFP_KERNEL);
    if (!ar2020) {
        return -ENOMEM;
    }

    ar2020->dev = &client->dev;
    ar2020->client = client;
    ar2020->cur_mode = &supported_modes[0];

    dev_info(ar2020->dev, "--> [AR2020/ar2020] [HieuCao Kernel Module Probing ver 3.0.0 ...] ");
    dev_info(ar2020->dev, "AR2020 probe starting, Finding I2C @ address: 0x%02x\n", client->addr);

    // sd = &ar2020->subdev;
    v4l2_i2c_subdev_init(&ar2020->sd, client, &ar2020_subdev_ops);

    ret = ar2020_parse_hw_config(ar2020);
	if (ret) {
		dev_err(ar2020->dev, "HW configuration is not supported");
		return ret;
	}

    ar2020->xvclk = devm_clk_get(ar2020->dev, "xvclk");
    if (IS_ERR(ar2020->xvclk)) {
        dev_err(ar2020->dev, "Failed to get xvclk\n");
        return PTR_ERR(ar2020->xvclk);
    }

    mutex_init(&ar2020->mutex);

    /* Initialize custom registers array */
    for (int i = 0; i < AR2020_MAX_CUSTOM_REGS; i++)
        ar2020->custom_regs_array[i].enabled = false;    

    ret = ar2020_initialize_controls(ar2020);
    if (ret)
        goto err_destroy_mutex;

    ret = __ar2020_power_on(ar2020->dev);
    if (ret)
        goto err_free_handler;

    ret = ar2020_check_sensor_id(ar2020);
    if (ret) {
        dev_err(ar2020->dev, "Failed to detect AR2020 chip\n");
        goto err_power_off;
    }
    dev_info(ar2020->dev, "AR2020 chip detected successfully\n");

    ar2020->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
    ar2020->sd.entity.function = MEDIA_ENT_F_CAM_SENSOR;
    ar2020->sd.entity.ops = &ar2020_entity_ops;
	/* Initialize source pad */
	ar2020->pad.flags = MEDIA_PAD_FL_SOURCE;

    ret = media_entity_pads_init(&ar2020->sd.entity, 1, &ar2020->pad);
    if (ret) {
        dev_err(ar2020->dev, "Failed to init media entity: %d\n", ret);
        goto err_power_off;
    }
    dev_info(ar2020->dev, "Media entity initialized successfully\n");

    ret = v4l2_async_register_subdev_sensor(&ar2020->sd);
    if (ret) {
        dev_err(ar2020->dev, "Failed to register V4L2 subdev: %d\n", ret);
        goto err_clean_entity;
    }
    dev_info(ar2020->dev, "AR2020 V4L2 subdev registered successfully\n");

    pm_runtime_set_active(ar2020->dev);
    pm_runtime_enable(ar2020->dev);
    pm_runtime_idle(ar2020->dev);

    return 0;

err_clean_entity:
    media_entity_cleanup(&ar2020->sd.entity);
err_power_off:
    __ar2020_power_off(ar2020->dev);
err_free_handler:
    v4l2_ctrl_handler_free(ar2020->sd.ctrl_handler);
err_destroy_mutex:
    mutex_destroy(&ar2020->mutex);
    return ret;
}

static void ar2020_remove(struct i2c_client *client)
{
    struct v4l2_subdev *sd = i2c_get_clientdata(client);
    struct ar2020 *ar2020 = to_ar2020(sd);

    v4l2_async_unregister_subdev(sd);
    media_entity_cleanup(&sd->entity);
    v4l2_ctrl_handler_free(&ar2020->ctrl_handler);
    

    pm_runtime_disable(&client->dev);
    if (!pm_runtime_status_suspended(&client->dev))
        __ar2020_power_off(&client->dev);
    pm_runtime_set_suspended(&client->dev);

    mutex_destroy(&ar2020->mutex);
}

static const struct dev_pm_ops ar2020_pm_ops = {
	SET_RUNTIME_PM_OPS(__ar2020_power_off, __ar2020_power_on, NULL)
};

static const struct of_device_id ar2020_of_match[] = {
    { .compatible = "onsemi,ar2020" },
    {},
};

MODULE_DEVICE_TABLE(of, ar2020_of_match);

static struct i2c_driver ar2020_i2c_driver = {
    .driver = {
        .name = AR2020_NAME,
        .pm = &ar2020_pm_ops,
        .of_match_table = ar2020_of_match,
    },
    .probe_new = ar2020_probe,
    .remove = ar2020_remove,
};

module_i2c_driver(ar2020_i2c_driver);

MODULE_DESCRIPTION("Onsemi AR2020 sensor driver");
MODULE_AUTHOR("Cao Hieu");
MODULE_LICENSE("GPL");
