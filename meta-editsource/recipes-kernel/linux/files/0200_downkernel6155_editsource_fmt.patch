diff --git a/drivers/staging/media/imx/dwc-mipi-csi2.c b/drivers/staging/media/imx/dwc-mipi-csi2.c
index 8a24b0231596..93dd20971dc0 100644
--- a/drivers/staging/media/imx/dwc-mipi-csi2.c
+++ b/drivers/staging/media/imx/dwc-mipi-csi2.c
@@ -444,6 +444,8 @@ static void dwc_mipi_csi2_dump(struct dwc_mipi_csi2_host *csi2h)
 	dev_dbg(dev, "DWC CSI2 INT_MSK_BNDRY_FRAME_FATAL: %#x\n", dwc_mipi_csi2h_read(csi2h, 0x284));
 	dev_dbg(dev, "DWC CSI2 INT_MSK_SEQ_FRAME_FATAL: %#x\n", dwc_mipi_csi2h_read(csi2h, 0x294));
 	dev_dbg(dev, "DWC CSI2 INT_MSK_DATA_ID: %#x\n", dwc_mipi_csi2h_read(csi2h, 0x2c4));
+
+	dev_dbg(dev, "IPI FATAL 140: %#x\n", dwc_mipi_csi2h_read(csi2h, DWC_MIPI_CSI2_INT_ST_IPI_FATAL));
 }
 
 static void gasket_dump(struct dwc_mipi_csi2_host *csi2h)
@@ -453,19 +455,19 @@ static void gasket_dump(struct dwc_mipi_csi2_host *csi2h)
 	u32 val;
 
 	regmap_read(gasket, DISP_MIX_CAMERA_MUX, &val);
-	dev_dbg(dev, "gasket: CAMERA MUX: %#x\n", val);
+	dev_dbg(dev, "Gasket: CAMERA MUX: %#x\n", val);
 
 	regmap_read(gasket, DISP_MIX_CSI_REG, &val);
-	dev_dbg(dev, "gasket: CSI REG: %#x\n", val);
+	dev_dbg(dev, "Gasket: CSI REG: %#x\n", val);
 
 	regmap_read(gasket, 0x3C, &val);
-	dev_dbg(dev, "gasket: MIPI -> ISI pixel ctrl: %#x\n", val);
+	dev_dbg(dev, "Gasket: MIPI -> ISI pixel ctrl: %#x\n", val);
 
 	regmap_read(gasket, 0x40, &val);
-	dev_dbg(dev, "gasket: MIPI -> ISI pixel cnt: %#x\n", val);
+	dev_dbg(dev, "Gasket: MIPI -> ISI pixel cnt: %#x\n", val);
 
 	regmap_read(gasket, 0x44, &val);
-	dev_dbg(dev, "gasket: MIPI -> ISI line cnt: %#x\n", val);
+	dev_dbg(dev, "Gasket: MIPI -> ISI line cnt: %#x\n", val);
 }
 
 static inline struct dwc_mipi_csi2_host *sd_to_dwc_mipi_csi2h(
@@ -559,7 +561,7 @@ static void dwc_pattern_generate(struct dwc_mipi_csi2_host *csi2h)
 	val = (csi2h->ppi_pg_enable) ? DWC_MIPI_CSI2_PPI_PG_ENABLE_EN : 0;
 	dwc_mipi_csi2h_write(csi2h, DWC_MIPI_CSI2_PPI_PG_ENABLE, val);
 
-	dev_dbg(dev, "enable DWC MIPI CSI2 pattern generator\n");
+	dev_dbg(dev, "Enable DWC MIPI CSI2 pattern generator\n");
 }
 
 static void dwc_mipi_csi2_dphy_reset(struct dwc_mipi_csi2_host *csi2h)
@@ -618,7 +620,7 @@ static void dwc_mipi_csi2_ipi_config_htiming(struct dwc_mipi_csi2_host *csi2h)
 	val = DWC_MIPI_CSI2_IPI_HLINE_TIME_VAL(ipi_cfg->hline_time);
 	dwc_mipi_csi2h_write(csi2h, DWC_MIPI_CSI2_IPI_HLINE_TIME, val);
 
-	dev_dbg(dev, "hsa_time=%d, hbp_time=%d, hsd_time=%d, hline_time=%d\n",
+	dev_dbg(dev, "ipi_cfg: hsa_time=%d, hbp_time=%d, hsd_time=%d, hline_time=%d\n",
 		ipi_cfg->hsa_time, ipi_cfg->hbp_time,
 		ipi_cfg->hsd_time, ipi_cfg->hline_time);
 }
@@ -641,7 +643,7 @@ static void dwc_mipi_csi2_ipi_config_vtiming(struct dwc_mipi_csi2_host *csi2h)
 	val = DWC_MIPI_CSI2_IPI_VACTIVE_LINES_VAL(ipi_cfg->vactive_lines);
 	dwc_mipi_csi2h_write(csi2h, DWC_MIPI_CSI2_IPI_VACTIVE_LINES, val);
 
-	dev_dbg(dev, "vsa_lines=%d, vbp_lines=%d, vsd_lines=%d, active_lines=%d\n",
+	dev_dbg(dev, "ipi_cfg: vsa_lines=%d, vbp_lines=%d, vsd_lines=%d, active_lines=%d\n",
 		ipi_cfg->vsa_lines, ipi_cfg->vbp_lines,
 		ipi_cfg->vfp_lines, ipi_cfg->vactive_lines);
 }
@@ -716,13 +718,16 @@ static void disp_mix_gasket_config(struct dwc_mipi_csi2_host *csi2h)
 	case MEDIA_BUS_FMT_SRGGB12_1X12:
 		fmt_val = DT_RAW12;
 		break;
+	case MEDIA_BUS_FMT_Y10_1X10:
+		fmt_val = DT_RAW10;
+		break;
 	default:
 		pr_err("gasket not support format %d\n", mf->code);
 		return;
 	}
 
 	if (csi2h->ppi_pg_enable)
-		fmt_val = DT_RGB888;
+		fmt_val = DT_RAW10;
 
 	regmap_write(gasket, DISP_MIX_CAMERA_MUX, 0x0);
 
@@ -733,7 +738,7 @@ static void disp_mix_gasket_config(struct dwc_mipi_csi2_host *csi2h)
 	val |= csi2h->yuv420_line_sel << 13;
 	regmap_write(gasket, DISP_MIX_CAMERA_MUX, val);
 
-	dev_dbg(dev, "format: %#x, w/h=(%d, %d)\n", mf->code, mf->width, mf->height);
+	dev_info(dev, "format: %#x, w/h=(%d, %d)\n", mf->code, mf->width, mf->height);
 	if (WARN_ON(!mf->width || !mf->height)) {
 		pr_err("Invaid width/height\n");
 		return;
@@ -851,7 +856,7 @@ static int dwc_mipi_csi2_host_ipi_config(struct dwc_mipi_csi2_host *csi2h)
 		val &= ~DWC_MIPI_CSI2_IPI_VCID_VC_2;
 	dwc_mipi_csi2h_write(csi2h, DWC_MIPI_CSI2_IPI_VCID, val);
 
-	dev_dbg(dev, "data_type:0x%x, virtual chan: %d\n",
+	dev_dbg(dev, "ipi_cfg: data_type:0x%x, virtual chan: %d\n",
 		ipi_cfg->data_type, ipi_cfg->vir_chan);
 
 	/* 1. Select the IPI mode, camera timing by default
@@ -880,7 +885,7 @@ static int dwc_mipi_csi2_host_ipi_config(struct dwc_mipi_csi2_host *csi2h)
 	if (ipi_cfg->controller_mode || csi2h->ppi_pg_enable)
 		dwc_mipi_csi2_ipi_config_vtiming(csi2h);
 
-	dev_dbg(dev, "ipi mode: %s, color_mode: %s\n",
+	dev_dbg(dev, "ipi_cfg: ipi mode: %s, color_mode: %s\n",
 		ipi_cfg->controller_mode ? "controller" : "camera",
 		ipi_cfg->color_mode_16   ? "color mode 16" : "color mode 48");
 
@@ -1001,7 +1006,7 @@ static int dwc_mipi_csi2_param_init(struct dwc_mipi_csi2_host *csi2h)
 		memset(ipi_cfg, 0x0, sizeof(*ipi_cfg));
 
 		if (csi2h->ppi_pg_enable) {
-			ipi_cfg->data_type  = DT_RGB888;
+			ipi_cfg->data_type  = DT_RAW10;
 			ipi_cfg->vir_chan   = 0;
 			ipi_cfg->hsa_time   = 3;
 			ipi_cfg->hbp_time   = 2;
@@ -1012,10 +1017,10 @@ static int dwc_mipi_csi2_param_init(struct dwc_mipi_csi2_host *csi2h)
 			ipi_cfg->vfp_lines  = 0xf;
 			ipi_cfg->vactive_lines   = 1080;
 			ipi_cfg->controller_mode = 0;
-			ipi_cfg->color_mode_16   = 0;
+			ipi_cfg->color_mode_16   = 1;
 			ipi_cfg->embeded_data    = 0;
 		} else {
-			ipi_cfg->data_type  = DT_YUV422_8;
+			ipi_cfg->data_type  = DT_RAW10;
 			ipi_cfg->vir_chan   = 0;
 			ipi_cfg->hsa_time   = 0;
 			ipi_cfg->hbp_time   = 0;
@@ -1026,7 +1031,7 @@ static int dwc_mipi_csi2_param_init(struct dwc_mipi_csi2_host *csi2h)
 			ipi_cfg->vfp_lines  = 0;
 			ipi_cfg->vactive_lines   = 0x320;
 			ipi_cfg->controller_mode = 0;
-			ipi_cfg->color_mode_16   = 0;
+			ipi_cfg->color_mode_16   = 1;
 			ipi_cfg->embeded_data    = 0;
 		}
 	}
@@ -1045,7 +1050,7 @@ static int dwc_mipi_csi2_param_init(struct dwc_mipi_csi2_host *csi2h)
 	of_property_read_u32(node, "cfg-clk-range", &csi2h->cfgclkfreqrange);
 	of_property_read_u32(node, "hs-clk-range", &csi2h->hsclkfreqrange);
 
-	dev_dbg(dev, "cfgclkfreqrange=%d, hsfreqrange=%d\n",
+	dev_info(dev, "cfgclkfreqrange=%d, hsfreqrange=%d\n",
 		 csi2h->cfgclkfreqrange, csi2h->hsclkfreqrange);
 	return 0;
 }
@@ -1204,16 +1209,26 @@ static int dwc_mipi_csi2_s_stream(struct v4l2_subdev *sd, int enable)
 
 	if (enable) {
 		pm_runtime_get_sync(dev);
+		dev_dbg(&csi2h->pdev->dev, "[s_stream] Pass Step 1: SOT");
 		dwc_mipi_csi2_host_startup(csi2h);
+		dev_dbg(&csi2h->pdev->dev, "[s_stream] Pass Step 2");
 		dwc_mipi_csi2_host_init(csi2h);
+		dev_dbg(&csi2h->pdev->dev, "[s_stream] Pass Step 3");
 		dwc_mipi_csi2_host_ipi_config(csi2h);
+		dev_dbg(&csi2h->pdev->dev, "[s_stream] Pass Step 4");
 		dwc_mipi_csi2_host_hs_rx_start(csi2h);
+		dev_dbg(&csi2h->pdev->dev, "[s_stream] Pass Step 5");
 		disp_mix_gasket_config(csi2h);
+		dev_dbg(&csi2h->pdev->dev, "[s_stream] Pass Step 6");
 		dwc_mipi_csi2_dump(csi2h);
+		dev_dbg(&csi2h->pdev->dev, "[s_stream] Pass Step 7");
 		gasket_dump(csi2h);
+		dev_dbg(&csi2h->pdev->dev, "[s_stream] Pass Step 8: EOT");
 	} else {
 		dwc_mipi_csi2_host_hs_rx_stop(csi2h);
+		dev_dbg(&csi2h->pdev->dev, "[s_stream] Pass Step 9: STOP-X");
 		pm_runtime_put(dev);
+		dev_dbg(&csi2h->pdev->dev, "[s_stream] Pass Step 10: STOP-Y");
 	}
 
 	return ret;
diff --git a/drivers/staging/media/imx/imx8-isi-cap.c b/drivers/staging/media/imx/imx8-isi-cap.c
index 7587f68a8c96..66b2ea2c260f 100644
--- a/drivers/staging/media/imx/imx8-isi-cap.c
+++ b/drivers/staging/media/imx/imx8-isi-cap.c
@@ -9,6 +9,8 @@
  *
  */
 
+#define DEBUG
+
 #include <linux/module.h>
 #include <linux/kernel.h>
 #include <linux/types.h>
@@ -54,6 +56,15 @@ struct mxc_isi_fmt mxc_isi_src_formats[] = {
 		.memplanes	= 1,
 		.colplanes	= 1,
 		.align		= 2,
+	}, {
+		.name		= "RAW10P",
+		.fourcc		= V4L2_PIX_FMT_SGRBG10,
+		.depth		= { 16 },
+		.color		= MXC_ISI_OUT_FMT_RAW16,
+		.memplanes	= 1,
+		.colplanes	= 1,
+		.align		= 2,
+		.mbus_code	= MEDIA_BUS_FMT_SGRBG10_1X10,
 	}
 };
 
@@ -85,7 +96,7 @@ struct mxc_isi_fmt *mxc_isi_find_format(const u32 *pixelformat,
 			def_fmt = fmt;
 		id++;
 	}
-	return def_fmt;
+	return &mxc_isi_out_formats[0];
 }
 
 struct mxc_isi_fmt *mxc_isi_get_src_fmt(struct v4l2_subdev_format *sd_fmt)
@@ -102,7 +113,7 @@ struct mxc_isi_fmt *mxc_isi_get_src_fmt(struct v4l2_subdev_format *sd_fmt)
 		index = 1;
 	else
 		index = 0;
-	return &mxc_isi_src_formats[index];
+	return &mxc_isi_src_formats[2];
 }
 
 static inline struct mxc_isi_buffer *to_isi_buffer(struct vb2_v4l2_buffer *v4l2_buf)
@@ -257,7 +268,7 @@ static int cap_vb2_queue_setup(struct vb2_queue *q,
 		sizes[i] = format->plane_fmt[i].sizeimage;
 	}
 
-	dev_dbg(&isi_cap->pdev->dev, "%s, buf_n=%d, size=%d\n",
+	dev_info(&isi_cap->pdev->dev, "%s, buf_n=%d, size=%d\n",
 		__func__, *num_buffers, sizes[0]);
 
 	return 0;
@@ -338,7 +349,7 @@ static int cap_vb2_start_streaming(struct vb2_queue *q, unsigned int count)
 	int i, j;
 	int ret;
 
-	dev_dbg(&isi_cap->pdev->dev, "%s\n", __func__);
+	dev_info(&isi_cap->pdev->dev, "%s\n", __func__);
 
 	if (count < 2) {
 		ret = -ENOBUFS;
@@ -370,7 +381,7 @@ static int cap_vb2_start_streaming(struct vb2_queue *q, unsigned int count)
 			ret = -ENOMEM;
 			goto err;
 		}
-		dev_dbg(&isi_cap->pdev->dev,
+		dev_info(&isi_cap->pdev->dev,
 			"%s: num_plane=%d discard_size=%d discard_buffer=%p\n"
 			, __func__, i,
 			PAGE_ALIGN((int)isi_cap->discard_size[i]),
@@ -443,7 +454,7 @@ static void cap_vb2_stop_streaming(struct vb2_queue *q)
 	unsigned long flags;
 	int i;
 
-	dev_dbg(&isi_cap->pdev->dev, "%s\n", __func__);
+	dev_info(&isi_cap->pdev->dev, "%s\n", __func__);
 
 	mxc_isi_channel_disable(mxc_isi);
 
@@ -510,7 +521,7 @@ static int mxc_isi_s_ctrl(struct v4l2_ctrl *ctrl)
 	struct mxc_isi_dev *mxc_isi = mxc_isi_get_hostdata(isi_cap->pdev);
 	unsigned long flags;
 
-	dev_dbg(&isi_cap->pdev->dev, "%s\n", __func__);
+	dev_info(&isi_cap->pdev->dev, "%s\n", __func__);
 
 	if (ctrl->flags & V4L2_CTRL_FLAG_INACTIVE)
 		return 0;
@@ -814,7 +825,7 @@ static int mxc_isi_cap_enum_fmt(struct file *file, void *priv,
 	struct mxc_isi_cap_dev *isi_cap = video_drvdata(file);
 	struct mxc_isi_fmt *fmt;
 
-	dev_dbg(&isi_cap->pdev->dev, "%s\n", __func__);
+	dev_info(&isi_cap->pdev->dev, "%s\n", __func__);
 	if (f->index >= (int)mxc_isi_out_formats_size)
 		return -EINVAL;
 
@@ -835,13 +846,13 @@ static int mxc_isi_cap_g_fmt_mplane(struct file *file, void *fh,
 	struct mxc_isi_frame *dst_f = &isi_cap->dst_f;
 	int i;
 
-	dev_dbg(&isi_cap->pdev->dev, "%s\n", __func__);
+	dev_info(&isi_cap->pdev->dev, "%s\n", __func__);
 
 	pix->width = dst_f->o_width;
 	pix->height = dst_f->o_height;
 	pix->field = V4L2_FIELD_NONE;
 	pix->pixelformat = dst_f->fmt->fourcc;
-	pix->colorspace = V4L2_COLORSPACE_SRGB;
+	pix->colorspace = V4L2_COLORSPACE_RAW;
 	pix->ycbcr_enc = V4L2_MAP_YCBCR_ENC_DEFAULT(pix->colorspace);
 	pix->quantization = V4L2_QUANTIZATION_FULL_RANGE;
 	pix->num_planes = dst_f->fmt->memplanes;
@@ -861,7 +872,7 @@ mxc_isi_cap_fmt_try(struct mxc_isi_cap_dev *isi_cap,
 	struct mxc_isi_fmt *fmt = NULL;
 	int i;
 
-	dev_dbg(&isi_cap->pdev->dev, "%s\n", __func__);
+	dev_info(&isi_cap->pdev->dev, "%s\n", __func__);
 
 	for (i = 0; i < mxc_isi_out_formats_size; i++) {
 		fmt = &mxc_isi_out_formats[i];
@@ -888,7 +899,7 @@ mxc_isi_cap_fmt_try(struct mxc_isi_cap_dev *isi_cap,
 	pix->num_planes = fmt->memplanes;
 	pix->pixelformat = fmt->fourcc;
 	pix->field = V4L2_FIELD_NONE;
-	pix->colorspace = V4L2_COLORSPACE_SRGB;
+	pix->colorspace = V4L2_COLORSPACE_RAW;
 	pix->ycbcr_enc = V4L2_MAP_YCBCR_ENC_DEFAULT(pix->colorspace);
 	pix->quantization = V4L2_QUANTIZATION_FULL_RANGE;
 	memset(pix->reserved, 0x00, sizeof(pix->reserved));
@@ -958,7 +969,7 @@ static int mxc_isi_source_fmt_init(struct mxc_isi_cap_dev *isi_cap)
 
 	src_fmt.pad = source_pad->index;
 	src_fmt.which = V4L2_SUBDEV_FORMAT_ACTIVE;
-	src_fmt.format.code = MEDIA_BUS_FMT_UYVY8_1X16;
+	src_fmt.format.code = MEDIA_BUS_FMT_SGRBG10_1X10;
 	src_fmt.format.width = dst_f->width;
 	src_fmt.format.height = dst_f->height;
 	ret = v4l2_subdev_call(src_sd, pad, set_fmt, NULL, &src_fmt);
@@ -1011,7 +1022,7 @@ static int mxc_isi_cap_s_fmt_mplane(struct file *file, void *priv,
 	 * Step5: Update mxc isi channel configuration.
 	 */
 
-	dev_dbg(&isi_cap->pdev->dev, "%s, fmt=0x%X\n", __func__, pix->pixelformat);
+	dev_info(&isi_cap->pdev->dev, "%s, fmt=0x%X\n", __func__, pix->pixelformat);
 	if (vb2_is_busy(&isi_cap->vb2_q))
 		return -EBUSY;
 
@@ -1087,7 +1098,7 @@ static int mxc_isi_cap_streamon(struct file *file, void *priv,
 	struct v4l2_subdev *src_sd;
 	int ret;
 
-	dev_dbg(dev, "%s\n", __func__);
+	dev_info(dev, "%s\n", __func__);
 
 	if (!isi_cap->is_streaming[isi_cap->id]) {
 		src_sd = mxc_get_remote_subdev(&isi_cap->sd, __func__);
@@ -1139,7 +1150,7 @@ static int mxc_isi_cap_streamoff(struct file *file, void *priv,
 	struct v4l2_subdev *src_sd;
 	int ret;
 
-	dev_dbg(dev, "%s\n", __func__);
+	dev_info(dev, "%s\n", __func__);
 
 	ret = vb2_ioctl_streamoff(file, priv, type);
 	if (ret < 0)
@@ -1165,7 +1176,7 @@ static int mxc_isi_cap_g_selection(struct file *file, void *fh,
 	struct mxc_isi_cap_dev *isi_cap = video_drvdata(file);
 	struct mxc_isi_frame *f = &isi_cap->dst_f;
 
-	dev_dbg(&isi_cap->pdev->dev, "%s\n", __func__);
+	dev_info(&isi_cap->pdev->dev, "%s\n", __func__);
 
 	if (s->type != V4L2_BUF_TYPE_VIDEO_OUTPUT &&
 	    s->type != V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE)
@@ -1213,7 +1224,7 @@ static int mxc_isi_cap_s_selection(struct file *file, void *fh,
 	struct v4l2_rect rect = s->r;
 	unsigned long flags;
 
-	dev_dbg(&isi_cap->pdev->dev, "%s\n", __func__);
+	dev_info(&isi_cap->pdev->dev, "%s\n", __func__);
 	if (s->type != V4L2_BUF_TYPE_VIDEO_OUTPUT &&
 	    s->type != V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE)
 		return -EINVAL;
@@ -1477,7 +1488,7 @@ static int mxc_isi_subdev_get_fmt(struct v4l2_subdev *sd,
 	/* Source/Sink pads crop rectangle size */
 	mf->width = f->width;
 	mf->height = f->height;
-	mf->colorspace = V4L2_COLORSPACE_SRGB;
+	mf->colorspace = V4L2_COLORSPACE_RAW;
 
 	mutex_unlock(&isi_cap->lock);
 
@@ -1613,7 +1624,7 @@ static int mxc_isi_subdev_set_selection(struct v4l2_subdev *sd,
 		spin_unlock_irqrestore(&isi_cap->slock, flags);
 	}
 
-	dev_dbg(&isi_cap->pdev->dev, "%s, target %#x: (%d,%d)/%dx%d", __func__,
+	dev_info(&isi_cap->pdev->dev, "%s, target %#x: (%d,%d)/%dx%d", __func__,
 		sel->target, r->left, r->top, r->width, r->height);
 
 	mutex_unlock(&isi_cap->lock);
@@ -1640,7 +1651,7 @@ static int mxc_isi_register_cap_device(struct mxc_isi_cap_dev *isi_cap,
 	struct vb2_queue *q = &isi_cap->vb2_q;
 	int ret = -ENOMEM;
 
-	dev_dbg(&isi_cap->pdev->dev, "%s\n", __func__);
+	dev_info(&isi_cap->pdev->dev, "%s\n", __func__);
 	memset(vdev, 0, sizeof(*vdev));
 	snprintf(vdev->name, sizeof(vdev->name), "mxc_isi.%d.capture", isi_cap->id);
 
@@ -1712,7 +1723,7 @@ static int mxc_isi_subdev_registered(struct v4l2_subdev *sd)
 	if (!isi_cap)
 		return -ENXIO;
 
-	dev_dbg(&isi_cap->pdev->dev, "%s\n", __func__);
+	dev_info(&isi_cap->pdev->dev, "%s\n", __func__);
 
 	ret = mxc_isi_register_cap_device(isi_cap, sd->v4l2_dev);
 	if (ret < 0)
@@ -1729,7 +1740,7 @@ static void mxc_isi_subdev_unregistered(struct v4l2_subdev *sd)
 	if (!isi_cap)
 		return;
 
-	dev_dbg(&isi_cap->pdev->dev, "%s\n", __func__);
+	dev_info(&isi_cap->pdev->dev, "%s\n", __func__);
 
 	mutex_lock(&isi_cap->lock);
 	vdev = &isi_cap->vdev;
diff --git a/drivers/staging/media/imx/imx8-isi-fmt.c b/drivers/staging/media/imx/imx8-isi-fmt.c
index db11c809a3d3..6a3fc722b9df 100644
--- a/drivers/staging/media/imx/imx8-isi-fmt.c
+++ b/drivers/staging/media/imx/imx8-isi-fmt.c
@@ -8,95 +8,14 @@
 
 struct mxc_isi_fmt mxc_isi_out_formats[] = {
 	{
-		.name		= "RGB565",
-		.fourcc		= V4L2_PIX_FMT_RGB565,
+		.name		= "RAW10P",
+		.fourcc		= V4L2_PIX_FMT_SBGGR10,
 		.depth		= { 16 },
-		.color		= MXC_ISI_OUT_FMT_RGB565,
-		.memplanes	= 1,
-		.colplanes	= 1,
-		.align		= 3,
-		.mbus_code  = MEDIA_BUS_FMT_RGB565_1X16,
-	}, {
-		.name		= "RGB24",
-		.fourcc		= V4L2_PIX_FMT_RGB24,
-		.depth		= { 24 },
-		.color		= MXC_ISI_OUT_FMT_BGR32P,
-		.memplanes	= 1,
-		.colplanes	= 1,
-		.align		= 2,
-		.mbus_code  = MEDIA_BUS_FMT_RGB888_1X24,
-	}, {
-		.name		= "BGR24",
-		.fourcc		= V4L2_PIX_FMT_BGR24,
-		.depth		= { 24 },
-		.color		= MXC_ISI_OUT_FMT_RGB32P,
-		.memplanes	= 1,
-		.colplanes	= 1,
-		.align		= 2,
-		.mbus_code  = MEDIA_BUS_FMT_BGR888_1X24,
-	}, {
-		.name		= "YUYV-16",
-		.fourcc		= V4L2_PIX_FMT_YUYV,
-		.depth		= { 16 },
-		.color		= MXC_ISI_OUT_FMT_YUV422_1P8P,
-		.memplanes	= 1,
-		.colplanes	= 1,
-		.align		= 3,
-		.mbus_code	= MEDIA_BUS_FMT_YUYV8_1X16,
-	}, {
-		.name		= "YUV32 (X-Y-U-V)",
-		.fourcc		= V4L2_PIX_FMT_YUV32,
-		.depth		= { 32 },
-		.color		= MXC_ISI_OUT_FMT_YUV444_1P8,
-		.memplanes	= 1,
-		.colplanes	= 1,
-		.align		= 2,
-		.mbus_code	= MEDIA_BUS_FMT_AYUV8_1X32,
-	}, {
-		.name		= "NV12 (YUYV)",
-		.fourcc		= V4L2_PIX_FMT_NV12,
-		.depth		= { 8, 8 },
-		.color		= MXC_ISI_OUT_FMT_YUV420_2P8P,
-		.memplanes	= 1,
-		.colplanes	= 2,
-		.align		= 4,
-		.mbus_code	= MEDIA_BUS_FMT_YUYV8_1X16,
-	}, {
-		.name		= "NV12M (YUYV)",
-		.fourcc		= V4L2_PIX_FMT_NV12M,
-		.depth		= { 8, 8 },
-		.color		= MXC_ISI_OUT_FMT_YUV420_2P8P,
-		.memplanes	= 2,
-		.colplanes	= 2,
-		.align		= 4,
-		.mbus_code	= MEDIA_BUS_FMT_YUYV8_1X16,
-	}, {
-		.name		= "YUV444M (Y-U-V)",
-		.fourcc		= V4L2_PIX_FMT_YUV444M,
-		.depth		= { 8, 8, 8 },
-		.color		= MXC_ISI_OUT_FMT_YUV444_3P8P,
-		.memplanes	= 3,
-		.colplanes	= 3,
-		.align		= 4,
-		.mbus_code	= MEDIA_BUS_FMT_YUV8_1X24,
-	}, {
-		.name		= "xBGR32",
-		.fourcc		= V4L2_PIX_FMT_XBGR32,
-		.depth		= { 32 },
-		.color		= MXC_ISI_OUT_FMT_XRGB32,
-		.memplanes	= 1,
-		.colplanes	= 1,
-		.align		= 2,
-		.mbus_code	= MEDIA_BUS_FMT_RGB888_1X24,
-	}, {
-		.name		= "ABGR32",
-		.fourcc		= V4L2_PIX_FMT_ABGR32,
-		.depth		= { 32 },
-		.color		= MXC_ISI_OUT_FMT_ARGB32,
+		.color		= MXC_ISI_OUT_FMT_RAW16,
 		.memplanes	= 1,
 		.colplanes	= 1,
 		.align		= 2,
-		.mbus_code	= MEDIA_BUS_FMT_RGB888_1X24,
+		.mbus_code	= MEDIA_BUS_FMT_SBGGR10_1X10,
 	}
 };
 
diff --git a/drivers/staging/media/imx/imx8-isi-m2m.c b/drivers/staging/media/imx/imx8-isi-m2m.c
index 671318b394d7..c1262e80a247 100644
--- a/drivers/staging/media/imx/imx8-isi-m2m.c
+++ b/drivers/staging/media/imx/imx8-isi-m2m.c
@@ -41,40 +41,14 @@
 struct mxc_isi_fmt mxc_isi_input_formats[] = {
 	/* Pixel link input format */
 	{
-		.name		= "XBGR32",
-		.fourcc		= V4L2_PIX_FMT_XBGR32,
-		.depth		= { 32 },
-		.color =	MXC_ISI_M2M_IN_FMT_XRGB8,
-		.memplanes	= 1,
-		.colplanes	= 1,
-	}, {
-		.name		= "RGB565",
-		.fourcc		= V4L2_PIX_FMT_RGB565,
+		.name		= "RAW10P",
+		.fourcc		= V4L2_PIX_FMT_SGRBG10,
 		.depth		= { 16 },
-		.color =	MXC_ISI_M2M_IN_FMT_RGB565,
-		.memplanes	= 1,
-		.colplanes	= 1,
-	}, {
-		.name		= "YUV32 (X-Y-U-V)",
-		.fourcc		= V4L2_PIX_FMT_YUV32,
-		.depth		= { 32 },
-		.color = MXC_ISI_M2M_IN_FMT_YUV444_1P8P,
-		.memplanes	= 1,
-		.colplanes	= 1,
-	}, {
-		.name		= "YUV16 (X-Y-U-V)",
-		.fourcc		= V4L2_PIX_FMT_YUYV,
-		.depth		= { 16 },
-		.color = MXC_ISI_M2M_IN_FMT_YUV422_1P8P,
-		.memplanes	= 1,
-		.colplanes	= 1,
-	}, {
-		.name		= "RGBA (R-G-B-A)",
-		.fourcc		= V4L2_PIX_FMT_RGBA32,
-		.depth		= { 32 },
-		.color = MXC_ISI_M2M_IN_FMT_XBGR8,
+		.color		= MXC_ISI_OUT_FMT_RAW16,
 		.memplanes	= 1,
 		.colplanes	= 1,
+		.align		= 2,
+		.mbus_code	= MEDIA_BUS_FMT_SGRBG10_1X10,
 	}
 };
 
